<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            background-image: url("img/poker.png");
        }
        img {
            margin-top: 5px;
            margin-bottom: 5px;
            margin-left: 2px;
            margin-right: 2px;
            width: 100px;
            height: 100px;
        }
        #container {
            display: grid;
            grid-template-columns: 1fr 3fr 1fr;
        }
        #gameArea {
            text-align: center;
            display: inline;
            height: 500px;
            width: 500px;
            position: static;
            margin-top: 50px;
            margin-bottom: 50px;
            margin-left: 10px;
            margin-right: 10px;
        }
        #btnArea {
            text-align: center
        }
        button {
            display: inline-block;
            margin: 0;
            padding: 0;
            position: relative;
            border: none;
            min-width: 200px;
            min-height: 50px;
            background: linear-gradient(
                90deg,
                rgba(129, 230, 217, 1) 0%,
                rgba(79, 209, 197, 1) 100%
            );
            border-radius: 1000px;
            color: darkslategray;
            cursor: pointer;
            box-shadow: 12px 12px 24px rgba(79, 209, 197, 0.64);
            font-weight: 700;
            transition: 0.3s;
        }
        #firstPlayerArea {
            text-align: center;
            display: inline;
            float : left;
            margin-top: 3em;
            margin-bottom: 3em;
        }
        #secondPlayerArea {
            text-align: center;
            display: inline;
            float : right;
            margin-top: 3em;
            margin-bottom: 3em;
        }
        #playerRecordArea {
            display: inline;
        }
        #playerArea {
            display: inline;
        }

        .title {
            color: white;
            font-style: italic;
            font-size : 25px;
            display: inline;
        }

        #leftPlayerArea {
            float : left;
        }
        #rightPlayerArea {
            float : right;
        }

        .record {
            color : yellow;
            font-style: oblique;
        }
        
    </style>
</head>

<body>
    <h1 style="text-align: center; color : white">Poker Game 🎰</h1>
    <div style="text-align: center; color : white;">
        <input id="userInformation" type="text">
        <button onclick="clickCreatePlayerButton('userInformation')">Create Your Player!!🤹🏻‍♂️</button>
    </div>
    

    <span>
        <div id="firstPlayerArea"></div>
        <div id="secondPlayerArea"></div>
    </span>

    <br>
    <br>
    <br>
    <br>
    <br>
    <br>


    <div id="gameArea">
        <div id="cardArea"></div>
    </div>

    <br>
    <br>
    <br>
    
    <div id="btnArea">
        <button onclick="selectFirstPlayer()">
            플레이어1 시작
        </button>
    
        <button onclick="getGameResult()">
            게임 결과 출력 
        </button>
    
        <button onclick="selectSecondPlayer()">
            플레이어2 시작
        </button>
        <button onclick="clickHintButton()">
            힌트
        </button>
        <button onclick="clickRuleButton()">
            룰 설명
        </button>
    </div>
    <script>
        window.onload = function() {
            alert('어서와 여늘이의 "Poker Game 🎰"은 처음이지?!💥');
            gameModerator = new GameModerator();
            gameModerator.startGame();
        }

        function clickRuleButton() {
            gameModerator.explainRule();
        }

    // 클래스 정의
        // 1. 아바타 생성기 ✅
        class AvatorGenerator {
            // 랜덤 아바타 저장 
            #avators;
            // 아바타 난수 생성기 
            #randomGeneratorForShuffleAvators;

            constructor() {
                // 프라이빗 필드에 기본값 세팅 
                this.#avators = ["🤹🏻‍♂️", "👨🏻‍🎤", "👩🏻‍🍳", "🦹🏻‍♂️", "🤵🏻‍♂️", "🧝🏻‍♀️", "🦸🏻‍♀️", "🧙🏻", "👰🏻‍♀️"];
                this.#randomGeneratorForShuffleAvators = () => Math.random() - 0.5;
            }

            // 아바타 생성 
            createAvator() {
                return this.selectRandomAvator();
            }

            // 랜덤 아바타 선택 
            selectRandomAvator() {
                this.suffleAllAvator();
                return this.#avators[0];
            }

            // 아바타 배열 섞기 
            suffleAllAvator() {
                for (let i=0; i<100; i++) {
                    this.#avators.sort(this.#randomGeneratorForShuffleAvators);
                }
            }

        }  


        // 2. 카드 객체 ✅
        class Card {
            // 카드 이미지 숫자
            #cardImageNumber;
            // 카드 상태(앞면/뒷면), 불린 
            #front;

            constructor(cardImageNumber = 0, front = false) {
                this.#cardImageNumber = cardImageNumber;
                this.#front = front;
            }

            isFront() {
                return this.#front;
            }

            getNumber() {
                return this.#cardImageNumber % 13;
            }

            getShape() {
                return Math.floor(this.#cardImageNumber/13);
            }

            getColor() {
                return Math.floor(this.#cardImageNumber/13) % 2 === 0 ? 'red' : 'black';
            }

            getCardImageNumber() {
                return this.#cardImageNumber;
            }

            calculateSameCount(ohterNumber, otherColor, otherShape) {
                return this.isSameNumber(otherNumber) + this.isSameColor(otherColor) + this.isSameShape(otherShape);
            }

            isSameNumber(otherNumber) {
                return this.getNumber() === otherNumber ? 1 : 0;
            }

            isSameColor(otherColor) {
                return this.getColor() === otherColor ? 1 : 0;
            }

            isSameShape(otherShape) {
                return this.getShape() === otherShape ? 1 : 0;
            }
            isSameCardImageNumber(otherCardImageNumber) {
                return this.#cardImageNumber === otherCardImageNumber;
            }
            flip() {
                this.#front = !this.#front;
            }
        }

        // 3. 덱 객체 ✅
        class Deck {
            #FRIST_CARD_IMAGE_NUMBER;
            #LAST_CARD_IMAGE_NUMBER;
            #NUMBER_OF_CARD;
            #MAX_HINT_COUNT;
            #MAX_NUMBER_OF_SELECTED_CARD;

            #cardAllImageNumber;
            #cards;
            #selectedCardForHint;
            #currentPlayerTwoSelectedCard;

            #randomGenerator;
            #randomNumberGeneratorForShuffle;

            constructor() {
                this.#FRIST_CARD_IMAGE_NUMBER = 0;
                this.#LAST_CARD_IMAGE_NUMBER = 51;
                this.#NUMBER_OF_CARD = 52;
                this.#MAX_HINT_COUNT = 3;
                this.#MAX_NUMBER_OF_SELECTED_CARD = 2;

                this.#cardAllImageNumber = [];
                this.#cards = [];
                this.#selectedCardForHint = [];
                this.#currentPlayerTwoSelectedCard = [];

                this.#randomGenerator = () => Math.floor(Math.random()*this.#NUMBER_OF_CARD)
                this.#randomNumberGeneratorForShuffle = () => Math.random() - 0.5;
            }

            createDeck() {
                // 카드 이미지 숫자 배열 섞기 
                this.shuffleAllCardImageNumber();
                // 모든 카드 객체 생성 
                this.createAllCard();
            }

            shuffleAllCardImageNumber() {
                for (let i=0; i<100; i++) {
                    this.#cardAllImageNumber.sort(this.randomNumberGeneratorForShuffleCardImageNumber);
                }
            }

            createAllCard() {
                for (number of this.#cardAllImageNumber) {
                    this.#cards.push(new Card(number, false));
                }
            }

            selectRandomCard() {
                const randomNumber = this.#randomGenerator();

                for (card of cards) {
                    if (card.isSameCardImageNumber(randomNumber)) {
                        return card;
                    }
                }
            }

            // 📌 true/false 반환 
            showCardForHint() {
                if (this.isAllCardFront()) {
                    alert("이미 모든 카드가 앞면입니다.");
                    return;
                }

                while (true) {
                    const selectedCard = this.#selectedCardForHint();
                    if (!selectedCard.isFront()) {
                        this.#selectedCardForHint.push(selectedCard);
                        selectedCard.flip();
                        // 이후에 게임 진행자랑 플레이어 처리
                            // 게임 진행자 게임판 업데이트
                            // 현재 플레이어의 힌트 개수 1 카운트 다운
                        return true;
                    }
                }

                return false;
            }

            isAllCardFront() {
                for (card of this.#cards) {
                    if (!card.isFront()) {
                        return false;
                    }
                }

                return true;
            }

            getLengthOfCardForHint() {
                return this.#selectedCardForHint.length;
            }

            
            indexOfCardForHint(index) {
                if (!(0 <= index && index < this.getLengthOfCardForHint())) {
                    alert(`잘못된 인덱스 범위입니다. ${index}`);
                    return;
                }

                return this.#selectedCardForHint[index];
            }

            getLengthOfCurrentPlayerSelectedCard() {
                return this.#currentPlayerTwoSelectedCard.length;
            }

            indexOfCurrentPlayerSelectedCard(index) {
                if (!(0 <= index && index < this.getLengthOfCurrentPlayerSelectedCard())) {
                    alert(`잘못된 인덱스 범위입니다. ${index}`);
                    return;
                }

                return this.#currentPlayerTwoSelectedCard[index];
            }

            getLengthOfAllCard() {
                return this.#cards.length;
            }

            indexOfCard(index) {
                if (!(0 <= index && index < this.getLengthOfAllCard())) {
                    alert(`잘못된 인덱스 범위입니다. ${index}`);
                    return;
                }

                return this.#cards[index];
            }

            shuffle() {
                if (this.#cards.length === 0) {
                    this.createDeck();
                }

                this.initAllCard();

                for (let i=0; i<100; i++) {
                    this.#cards.sort(this.#randomNumberGeneratorForShuffle);
                }
            }

            initAllCard() {
                for (card of this.#cards) {
                    if (card.isFront()) {
                        card.flip();
                    }
                } 
            }
            connectCardToCardImageNumber() {
                this.#cardAllImageNumber.splice(0);

                for (card of this.#cards) {
                    this.#cardAllImageNumber.push(card.getCardImageNumber());
                }
            }

            initDeck() {
                this.shuffle();
                this.initAllCard();
                this.connectCardToCardImageNumber();
                this.#selectedCardForHint.splice(0);
                this.#currentPlayerTwoSelectedCard.splice(0);
            }

            findCard(cardImageNumber) {
                for (card of this.#cards) {
                    if (card.isSameCardImageNumber(cardImageNumber)) {
                        return card;
                    }
                }
            }

            isCurrentPlayerSelectedTwoCard() {
                return this.#currentPlayerTwoSelectedCard.length === this.#MAX_NUMBER_OF_SELECTED_CARD;
            }

            pushCurrentPlayerSelectedCard(card) {
                if (this.isCurrentPlayerSelectedTwoCard()) return;

                this.#currentPlayerTwoSelectedCard.push(card);
            }

            shuftCurrentPlayerSelctedCard() {
                if (this.#currentPlayerTwoSelectedCard.length === 0) return;
                return this.#currentPlayerTwoSelectedCard.shift();
            }

            isHintCard() {
                return this.#selectedCardForHint.length > 0;
            }
            
        }


        // 4. 플레이어 객체 ✅
        class Player {
            #name;
            #score;
            #leftCount;
            #leftHintCount;

            constructor(name) {
                this.#name = name;
                this.#score = 0;
                this.#leftCount = 10;
                this.#leftHintCount = 3;
            }

            isWinner(otherPlayerScore) {
                return this.#score > otherPlayerScore ? -1 : (this.#score === otherPlayerScore ? 0 : 1);
            }

            isLeftCount() {
                return this.#leftCount > 0;
            }

            isLeftHintCount() {
                return this.#leftHintCount > 0;
            }

            getName() {
                return this.#name;
            }

            getLeftCount() {
                return this.#leftCount;
            }

            getLeftHintCount() {
                return this.#leftHintCount;
            }

            addScore(amount) {
                this.#score += amount;
            }

            decreaseCount() {
                if (this.#leftCount > 0) {
                    this.#leftCount--;
                }
            }

            decreaseHintCount() {
                if (this.#leftHintCount > 0) {
                    this.#leftHintCount--;
                }
            }
        }


        // 5. 게임 결과 객체 
        class GameMessage {
            #resultMessage;
            #ruleMessage;

            constructor() {
                this.#ruleMessage = new Map();
                this.#ruleMessage = ['안녕하세요"Poker Game 🎰"에 오신것을 환영합니다. 포커 게임을 시작하기 앞서 간단하게 룰을 설명하겠습니다. 각 플레이어는 5판의 판수와 3번의 힌트 기회가 주어집니다. 또한, 플레이어는 한판당 2개의 카드를 선택하면됩니다. 힌트의 경우 무작위로 뒷면의 카드 중 하나를 뒤집습니다. 이후에 카드를 뽑았을 때 해당 카드와 힌트 카드를 비교하여 점수를 합산합니다. 이때, 카드의 숫자, 모양, 색깔이 판단 기준이 되며 3중에 1개라도 맞추면 1점을 획득하고 2개를 맞추면 2점을 획득하며 두 카드는 앞면 상태로 놓여집니다.'];
            }

            createGameResultMessage(firstPlayerName, secondPlayerName) {
                map.set(-1, `${firstPlayerName}가 이겼습니다.`);
                map.set(0, `${firstPlayerName}와 ${secondPlayerName}가 비겼습니다.`);
                map.set(1, `${secondPlayerName}가 이겼습니다.`);
            }

            getRuleMessage() {
                return this.#ruleMessage[0];
            }

            getResultMessage(result) {
                return this.#ruleMessage.get(result);
            }
        }

        // 6. 게임 진행자 객체
        class GameModerator {
            #firstPlayer;
            #secondPlayer;
            #currentPlayer;

            #deck;
            #avatorGenerator;
            #gameMessage;


            constructor() {
                this.#firstPlayer = null;
                this.#secondPlayer = null;
                this.#currentPlayer = null;

                this.#deck = new Deck();
                this.#avatorGenerator = new AvatorGenerator();
                this.#gameMessage = new GameMessage();
            }

            explainRule() {
                const message = this.#gameMessage.getRuleMessage();
                alert(message);
            }

            giveHint() {
                this.#deck.selectRandomCard();
            }

            startGame() {
                this.#deck.createAllCard();
                this.#deck.shuffle();
                this.createCardArea();
                this.updatePlayerArea();
            }

            updateGame() {
                this.#deck.shuffle();
                this.updateCardArea();
                this.updatePlayerArea();
            }

            updateCardArea() {
                const cardAreaChildren = document.getElementById("cardArea").children();

                for (child of cardAreaChildren) {
                    for (let i=0; i<this.#deck.getLengthOfAllCard(); i++) {
                        const card = deck.indexOfCard(i);
                        if (card === null) return;

                        if (card.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                            if (card.isFront()) {
                                child.setAttribute("src", `img/card_img/${card.getCardImageNumber()}.png`);
                            }
                        }
                    }
                }
            }

            createGameMessage() {
                this.#gameMessage.createGameResultMessage(this.#firstPlayer.getName(), this.#secondPlayer.getName());
            }

            createCardArea() {
                // 카드 영역 태그 참조 
                const cardArea = document.getElementById("cardArea");
                // 해당 영역 내부 HTML 초기화 
                cardArea.innerHTML = "";

                for (let i=0; i<this.#deck.getLengthOfAllCard(); i++) {
                    const card = deck.indexOfCard(i);
                    const imgTag = document.createElement("img");

                    // 카드가 앞면인 경우 
                    if (card.isFront()) {
                        // 앞면으로 보여주기 
                        imgTag.setAttribute("src", `img/card_img/${card.getCardImageNumber()}.png`);
                    } else {
                        // 그게 아니면, 뒷면으로 보여주기 
                        imgTag.setAttribute("src", `img/card_img/back.png`);
                    }

                    // 태그에 카드 이미지 숫자 저장 
                    imgTag.setAttribute("data-number", card.getCardImageNumber());
                    // 태그에 함수 연결 
                    imgTag.setAttribute("onclick", "selectCardTag(this)");
                    // 이미지 태그 카드 영역 태그에 추가 
                    cardArea.appendChild(imgTag);
                }

            }

            createPlayerArea() {
                // 첫 번째 플레이어 영역과 두 번째 플레이어 영역 참조 
                const firstPlayerArea = document.getElementById("firstPlayerArea");
                const secondPlayerArea = document.getElementById("secondPlayerArea");

                // 첫 번재 플레이어와 두 번재 플레이어 영역의 내부 HTML 초기화
                firstPlayerArea.innerHTML = "";
                secondPlayerArea.innerHTML = "";
                
                // 첫 번째 플레이어가 생성된 경우 
                if (this.#firstPlayer !== null) {
                    // 첫 번째 플레이어 영역 업데이트
                    firstPlayerArea.innerHTML = `<h3 class="title">${this.#firstPlayer.getName()}</h3>`;
                    firstPlayerArea.innerHTML += `<br>`;
                    firstPlayerArea.innerHTML += `<p class="record"><strong>👉 남은 횟수-${this.#firstPlayer.getLeftCount()}, 현재 점수-${this.#firstPlayer.getScore()}, 남은 힌트-${this.#firstPlayer.getLeftHintCount()} 👯‍♀️</strong></p>`;    
                }
                
                // 두 번째 플레이어가 생성된 경우
                if (this.#secondPlayer !== null) {
                    // 두 번째 플레이어 영역 업데이트 
                    secondPlayerArea.innerHTML = `<h3 class="title">${this.#secondPlayer.getName()}</h3>`
                    secondPlayerArea.innerHTML += `<br>`;
                    secondPlayerArea.innerHTML += `<p class="record"><strong>👉 남은 횟수-${this.#secondPlayer.getLeftCount()}, 현재 점수-${secondPlayer.getScore()}, 남은 힌트-${this.#secondPlayer.getLeftHintCount()} 👯‍♀️</strong></p>`;
                }
            }

            updatePlayerArea() {
                // 첫 번째 플레이어 영역과 두 번째 플레이어 영역 참조 
                const firstPlayerArea = document.getElementById("firstPlayerArea");
                const secondPlayerArea = document.getElementById("secondPlayerArea");

                // 첫 번재 플레이어와 두 번재 플레이어 영역의 내부 HTML 초기화
                firstPlayerArea.innerHTML = "";
                secondPlayerArea.innerHTML = "";

                firstPlayerArea.innerHTML = `<h3 class="title">${this.#firstPlayer.getName()}</h3>`;
                firstPlayerArea.innerHTML += `<br>`;
                firstPlayerArea.innerHTML += `<p class="record"><strong>👉 남은 횟수-${this.#firstPlayer.getLeftCount()}, 현재 점수-${this.#firstPlayer.getScore()}, 남은 힌트-${this.#firstPlayer.getLeftHintCount()} 👯‍♀️</strong></p>`;    
                
                secondPlayerArea.innerHTML = `<h3 class="title">${this.#secondPlayer.getName()}</h3>`;
                secondPlayerArea.innerHTML += `<br>`;
                secondPlayerArea.innerHTML += `<p class="record"><strong>👉 남은 횟수-${this.#secondPlayer.getLeftCount()}, 현재 점수-${secondPlayer.getScore()}, 남은 힌트-${this.#secondPlayer.getLeftHintCount()} 👯‍♀️</strong></p>`;
            }

            setFirstPlayerOnCurrentPlayer() {
                if (this.#firstPlayer === null) {
                    return;
                }

                this.#currentPlayer = this.#firstPlayer;
            }

            setSecondPlayerOnCurrentPlayer() {
                if (this.#secondPlayer === null) {
                    return;
                }

                this.#currentPlayer = this.#secondPlayer;
            }

            occurPlayerSelectCard() {
                if (this.#currentPlayer === null) {
                    alert("플레이어 시작 버튼을 누르고 게임을 진행하세요.🔊");
                    return;
                }

                if (!this.#currentPlayer.isLeftCount()) {
                    // 현재 상태 알려주기 
                    alert(`"${this.#currentPlayer.getName()}"의 게임 횟수가 ${this.#currentPlayer.getLeftCount()}입니다.🔊`);
                    alert(`"${this.#currentPlayer.getName()}"의 점수는 ${this.#currentPlayer.getScore()}입니다.🔊`);
                    // 태그 업데이트 
                    this.updatePlayerArea();
                    return;                    
                }

                // 플레이어가 선택한 태그에 대응되는 카드 가져옴 
                const currentPlayerSelectedCard = this.findSelectedCardByTag(selectedCardTag);
                if (currentPlayerSelectedCard.isFront()) {
                    // 앞면인 경우 건너뛰기
                    return; 
                }

                // 첫번째 카드와 힌트 카드 비교, 번째 카드와 힌트 카드 비교 
                let sameCountForFirstSelectedCardWithHint = 0;
                let sameCountForSecondSelectecCardWithHint = 0;
                
                // 힌트 카드와 이전에 선택한 카드 먼저 비교 
                for (let i=0; i<this.#deck.getLengthOfCardForHint(); i++) {
                    // 힌트 카드 하나씩 참조
                    const cardForHint = this.#deck.indexOfCardForHint(i);
                    // 현재 플레이어가 선택한 카드 하나씩 참조 
                    for (let j=0; j<this.#deck.getLengthOfCurrentPlayerSelectedCard(); j++) {
                        const selectedCard = this.#deck.indexOfCard(j);
                        // 서로 일치하는 갯수 카운트 
                        const amount = selectedCard.calculateSameCount(cardForHint.getNumber(), cardForHint.getColor(), cardForHint.getShape());
                        
                        // 첫 번째 카드인 경우 "첫 번째 카드와 힌트 카드 비교"에 기록
                        if (j === 0) {
                            sameCountForFirstSelectedCardWithHint += amount;
                        } 
                        // 두 번째 카드인 경우 "두 번째 카드와 힌트 카드 비교"에 기록
                        else {
                            sameCountForSecondSelectecCardWithHint += amount;
                        }

                        // 스코어 업데이트
                        this.#currentPlayer.addScore(amount);
                        // 태그 업데이트 
                        this.updatePlayerArea();
                    }
                }
                
                if (this.#deck.isCurrentPlayerSelectedTwoCard()) {
                    const amount = this.getSameAmountBetweenTwoSelectedCard(sameCountForFirstSelectedCardWithHint, sameCountForSecondSelectecCardWithHint);
                    this.#currentPlayer.addScore(amount);
                    this.#currentPlayer.decreaseCount();
                    this.updatePlayerArea();
                    return;
                }

                this.#deck.pushCurrentPlayerSelectedCard(currentPlayerSelectedCard);
                this.showSelectedCard(selectedCardTag);
            }

            getSameAmountBetweenTwoSelectedCard(sameAmountWithHintForFirstCard, sameAmountWithHintForSecondCard) {
                // 햔재 플레이어가 선택한 카드 한장 빼내기(첫 번째 카드)
                const firstSelectedCard = this.#deck.shiftCurrentPlayerSelectedCard();
                // 현재 플레이어가 선택한 카드 한장 빼내기(두 번째 카드)
                const secondSelectedCard = this.#deck.shiftCurrentPlayerSelectedCard();
                // 서로 얼마나 맞는지 계산 
                const amount = firstSelectedCard.calculateSameCount(secondSelectedCard.getNumber(), secondSelectedCard.getColor(), secondSelectedCard.getShape());
                // 해당 카드 객체에 해당하는 태그의 속성 업데이트(뒷면으로 설정)  
                const cardAreaChildren = document.getElementById("cardArea").children;   

                // 선택한 두 카드의 숫자, 컬러, 모양 안 맞은 경우
                if (amount === 0) { 
                    // 모든 힌트 카드와 선택한 두카드가 서로 일치하는게 하나도 없을 때, 모두 뒤집기
                    if (sameAmountWithHintForFirstCard === 0 && sameAmountWithHintForSecondCard === 0) {
                        firstSelectedCard.flip(); // 첫번째 카드 뒤집기 
                        secondSelectedCard.flip(); // 두번째 카드 뒤집기 
                        for (child of cardAreaChildren) {
                            if (firstSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number"))) || secondSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            } 
                        }
                    } 
                    // 모든 힌트 카드와 선택한 두 번째 카드가 서로 일치하는 게 없을 때, 두 번째 카드만 뒤집기
                    else if (sameAmountWithHintForFirstCard !== 0 && sameAmountWithHintForSecondCard === 0) {
                        secondSelectedCard.flip();
                        for (child of cardAreaChildren) {
                            if (secondSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            }
                        }
                    }
                    // 모든 힌트 카드와 선택한 첫 번째 카드가 서로 일치하는 게 없을 때, 첫 번째 카드만 뒤집기
                    else if (sameAmountWithHintForFirstCard === 0 && sameAmountWithHintForSecondCard !== 0) {
                        firstSelectedCard.flip();
                        for (child of cardAreaChildren) {
                            if (firstSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            }
                        }
                    }
                } 

                return amount;
            }

            findSelectedCardByTag(selectedCardTag) {
                const selectedCardImageNumber = parseInt(selectedCardTag.getAttribute("data-number"));
                return this.#deck.findCard(selectedCardImageNumber);
            }

            showSelectedCard(selectedCardTag) {
                // 현재 플레이어의 게임 횟수가 0인 경우 
                if (!this.#currentPlayer.isLeftCount()) return; 
                // 현재 플레이어가 선택한 태그에 해당하는 카드 객체 찾기 
                const currentPlayerSelectedCard = this.findSelectedCardByTag(selectedCardTag); 
                
                // 카드 객체가 앞면이면 스킵 
                if (currentPlayerSelectedCard.isFront()) return; 
                // 카드 객체가 뒷면이였으면, 돌리기 
                currentPlayerSelectedCard.flip(); 
                // 카드 태그의 속성 업데이트 
                selectedCardTag.setAttribute("src", `img/card_img/${currentPlayerSelectedCard.getCardImageNumber()}.png`);
            
            }

            getGameResult() {
                if (this.#firstPlayer.isLeftCount() || this.#secondPlayer.isLeftCount()) { 
                    alert(`아직 플레이어의 판수가 남아있습니다. 모든 플레이어의 판수 다 끝나면 요청해주세요.🔊`);
                    return false;
                }

                // 게임 결과를 숫자로 반환
                const result = this.#firstPlayer.isWinner(this.#secondPlayer.getScore()); 
                // 숫자 결과를 문자 결과로 반환해서 출력 
                this.notifyGameResult(result); 
                return true;
            }

            notifyGameResult(result) {
                // 두 플레이어가 생성된 경우 게임 결과 메시지 생성 
                if (this.#firstPlayer !== null && this.#secondPlayer !== null) {
                    this.#gameMessage.createAllMessage();
                }

                // 게임 결과 숫자를 메시지로 반환
                const resultMessage = this.#gameMessage.translateGameMessage(result);
                // 게임 결과 메시지 알림 
                alert(resultMessage);                
            }

            getCurrentPlayerName() {
                return this.#currentPlayer.getName();
            }

            resetAllPlayer() {
                alert("플레이어의 기록을 초기화합니다.💥");
                // 첫 번째와 두 번째 그리고 현재 플레이어 삭제 
                this.#firstPlayer = null; 
                this.#secondPlayer = null; 
                this.#currentPlayer = null;
            }
        }

    </script>
</body>
</html>