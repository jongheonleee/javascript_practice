<!--카드 게임-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            background-image: url("img/poker.png");
        }
        img {
            margin-top: 5px;
            margin-bottom: 5px;
            margin-left: 2px;
            margin-right: 2px;
            width: 100px;
            height: 100px;
        }
        #container {
            display: grid;
            grid-template-columns: 1fr 3fr 1fr;
        }
        #gameArea {
            text-align: center;
            display: inline;
            height: 500px;
            width: 500px;
            position: static;
            margin-top: 50px;
            margin-bottom: 50px;
            margin-left: 10px;
            margin-right: 10px;
        }
        #btnArea {
            text-align: center
        }
        button {
            display: inline-block;
            margin: 0;
            padding: 0;
            position: relative;
            border: none;
            min-width: 200px;
            min-height: 50px;
            background: linear-gradient(
                90deg,
                rgba(129, 230, 217, 1) 0%,
                rgba(79, 209, 197, 1) 100%
            );
            border-radius: 1000px;
            color: darkslategray;
            cursor: pointer;
            box-shadow: 12px 12px 24px rgba(79, 209, 197, 0.64);
            font-weight: 700;
            transition: 0.3s;
        }
        #firstPlayerArea {
            text-align: center;
            display: inline;
            float : left;
            margin-top: 3em;
            margin-bottom: 3em;
        }
        #secondPlayerArea {
            text-align: center;
            display: inline;
            float : right;
            margin-top: 3em;
            margin-bottom: 3em;
        }
        #playerRecordArea {
            display: inline;
        }
        #playerArea {
            display: inline;
        }

        .title {
            color: white;
            font-style: italic;
            font-size : 25px;
            display: inline;
        }

        #leftPlayerArea {
            float : left;
        }
        #rightPlayerArea {
            float : right;
        }

        .record {
            color : yellow;
            font-style: oblique;
        }
        
    </style>
</head>
<body>
    <h1 style="text-align: center; color : white">Poker Game 🎰</h1>
    <div style="text-align: center; color : white;">
        <input id="userInformation" type="text">
        <button onclick="clickCreatePlayerButton('userInformation')">Create Your Player!!🤹🏻‍♂️</button>
    </div>
    

    <span>
        <div id="firstPlayerArea"></div>
        <div id="secondPlayerArea"></div>
    </span>

    <br>
    <br>
    <br>
    <br>
    <br>
    <br>


    <div id="gameArea">
        <div id="cardArea"></div>
    </div>

    <br>
    <br>
    <br>
    
    <div id="btnArea">
        <button onclick="selectFirstPlayer()">
            플레이어1 시작
        </button>
    
        <button onclick="getGameResult()">
            게임 결과 출력 
        </button>
    
        <button onclick="selectSecondPlayer()">
            플레이어2 시작
        </button>
        <button onclick="clickHintButton()">
            힌트
        </button>
        <button onclick="clickRuleButton()">
            룰 설명
        </button>
    </div>

    <script>
        // 4차 객체 설계도(업데이트 중) 
            // 객체 설계 
                // 1. 카드 객체 ✅
                    // iv -> cardImageNumber, state 
                        // cardImageNumber : 카드 이미지 숫자, 숫자형 
                        // state : 상태, 앞면인지 뒷면인지, boolean 

                    // im -> getNumber(), getShape(), getColor(), getCardImageNumber(), isFront(), isSameNumber(), isSameColor(), isSameShape(), isSameCardImageNumber(), flip()
                        // getNumber() : 카드 숫자 추출
                        // getShape() : 카드 모양 추출
                        // getColor() : 카드 색깔 추출 
                        // getCardImageNumber() : 카드 이미지 숫자 반환 
                        // isFront() : 카드가 앞면인지 응답
                        // isSameNumber() : 매개변수로 전달 받은 카드의 숫자와 같은지 응답 
                        // isSameColor() : 매개변수로 전달 받은 카드의 색깔과 같은지 응답 
                        // isSameShape() : 매개변수로 전달 받은 카드의 모양과 같은지 응답 
                        // calculateSmaeCount() : 매개변수로 전달 받은 값들과 얼마나 맞았는지 계산해서 응답 
                        // isSameCardImageNumber() : 매개변수로 전달 받은 카드의 이미지 숫자와 같은지 응답  
                        // flip() : 카드 상태 반전 
                    

                

                // 2. 플레이어 객체 ✅
                    // iv -> name, score, leftCount
                        // name : 이름, 문자열
                        // score : 점수, 숫자형 
                        // leftCount : 남은 판수, 숫자형  

                    // im -> getName(), getScore(), getLeftCount(), isWinner(), isLeftCount(), addScore(), decreaseCount()
                        // getName() : 이름 반환
                        // getScore() : 점수 반환
                        // getLeftCount() : 남은 횟수 반환
                        // isWinner() : 자신이 승자인지, 패자인지, 무승부인지 응답
                        // isLeftCount() : 남은 횟수가 있는지 응답
                        // addScore() : 자신의 점수에 일정량 더함
                        // decreaseCount() : 남은 횟수를 1 감소함
            
                // 3. 게임 진행자 객체 ✅
                    // iv -> cardImageNumbers, FIRST_CARD_IMAGE_NUMBER, LAST_CARD_IMAGE_NUMBER, cards, currentPlayerSelectedTwoCard, firstPlayer, secondPlayer, currentPlayer, gameResultMessage
                        // cardImageNumbers : 카드 이미지 숫자를 저장하는 배열
                        // FIRST_CARD_IMAGE_NUMBER, LAST_CARD_IMAGE_NUMBER : 카드 이미지 숫자의 시작과 끝 숫자
                        // cards : 카드 객체 저장하는 배열
                        // currentPlayerSelectedTwoCard : 현재 플레이어가 선택한 2개의 카드를 저장하는 배열
                        // firstPlayer, secondPlayer, currentPlayer : 첫번째 플레이어 객체, 두번째 플레이어 객체, 현재 게임을 진행하는 플레이어 객체
                        // gameResultMessage : 게임 결과 숫자와 게임 결과 메시지를 매칭시켜서 저장한 맵

                    // im -> appendAllCardTag(), appendAllPlayerTag(), getCurrentPlayer(), getGameResult(), getSameAmountBetweenTwoSelectedCard(), 
                           // createAllCard(), createAllPlayer(), createGameResultMessage(), updateGame(), updateAllPlayerTag(), occurPlayerSelectCard(),
                           // startGame(), suffleAllCard(), suffleAllCardImageNumber(), setFirstPlayerOnCurrentPlayer(), setSecondPlayerOnCurrentPlayer(), showSelectedCard(),
                           // hideAllFrontCard(), findSelectedCardByTag(), notifyGameResult(), resetAllPlayer()
                            // appendAllCardTag() : 모든 카드 객체의 태그를 생성해서 추가
                            // appendAllPlayerTag() : 모든 플레이어 객체의 태그를 생성해서 추가
                            // getCurrentPlayer() : 현재 플레이어를 반환
                            // getGameResult() : 현재 게임 결과 숫자를 반환
                            // getSameAmountBetweenTwoSelectedCard() : 현재 플레이어가 선택한 2개의 카드 중에서 무엇이 맞는지 반환(숫자, 색깔, 도형)
                            // createAllCard() : 모든 카드 객체를 생성
                            // createAllPlayer() : 모든 플레이어 객체를 생성
                            // createGameResultMessage() : 모든 게임 결과 메시지를 생성해서 맵에 게임 결과 숫자와 매핑하여 저장
                            // updateGame() : 게임판 업데이트
                            // updateAllPlayerTag() : 모든 플레이어의 태그 업데이트
                            // occurPlayerSelectCard() : 플레이어가 카드를 선택했을 때 처리해줘야 할 작업
                            // startGame() : 게임이 시작됐을 때 초기 화면, 상태 구성
                            // suffleAllCard() : 모든 카드 객체를 섞음
                            // suffleAllCardImageNumber() : 모든 카드 이미지 숫자를 섞음
                            // setFirstPlayerOnCurrentPlayer(), setSecondPlayerOnCurrentPlayer() : 현재 플레이어 세팅
                            // showSelectedCard() : 선택한 카드를 화면에 보여줌
                            // hideAllFrontCard() : 앞면인 카드를 모두 뒷면으로 돌려줌
                            // findSelectedCardByTag() : 선태한 태그와 매칭되는 카드 객체 찾기
                            // notifyGameResult() : 게임 결과 발표
                            // resetAllPlayer() : 모든 플레이어 초기화 


                // 4. 게임 헬퍼 객체 ✅
                    // iv -> avators, NUMBER_OF_CARD
                        // avators : 아바타 저장한 배열
                        // NUMBER_OF_CARD : 52, 총 카드 개수 

                    // im -> explainRule(), createPlayer(), selectRandomAvator(), suffleAllAvator(), giveHint()
                        // explainRule() : 게임 룰 메시지 출력
                        // createPlayer() : 플레이어 객체 생성
                        // selectRandomAvator() : 랜덤 아바타 선택
                        // suffleAllAvator() : 아바타 배열 섞기
                        // giveHint() : 플레이어에게 힌트 주기(deck에서 핸덤 카드 한장 뒤집어주기)

                        
                // 5. 게임 결과 객체 ✅
                    // iv -> map
                        // map : 숫자로 이루어진 게임 결과와 그에 상으하는 결과 메시지 저장

                    // im -> createAllMessage(), translateGameMessage()
                        // createAllMessage() : 게임 결과 메시지 생성
                        // translateGameMessage() : 매개변수로 전달된 값과 매칭되는 게임 결과 메시지를 반환함


                // 6. 덱(카드 묶음) 객체 ✅
                    // iv -> FIRTS_CARD_IMAGE_NUMBER, LAST_CARD_IMAGE_NUMBER, NUMBER_OF_CARD, MAX_HINT_COUNT, cardAllImageNumber,
                    //       cards, selectedCardForHint, currentPlayerTwoSelectedCard, randomGenerator
                        // FIRTS_CARD_IMAGE_NUMBER : 첫번째 카드 이미지 숫자
                        // LAST_CARD_IMAGE_NUMBER : 마지막 카드 이미지 숫자 
                        // NUMBER_OF_CARD : 카드 개수
                        // MAX_HINT_COUNT : 최대 힌트 허용 개수
                        // cardAllImageNumber : 모든 카드 이미지 넘버 저장한 배열
                        // cards : 카드 객체 저장한 배열
                        // selectedCardForHint : 선택한 힌트 카드
                        // currentPlayerTwoSelectedCard : 현재 플레이어가 선택한 2개의 카드를 저장하는 배열
                        // randomGenerator : 난수 생성기 

                    // im -> createDeck(), shuffleAllCardImageNumber(), createAllCard(), selectRandomCard(), showCardForHint(), isAllCardFront(),
                    //       getLengthOfCardForHint(), indexOfCardForHint(), getLengthCurrentPlayerSelectedCard(), indexOfCurrentPlayerSelectedCard(),
                    //       getLengthOfAllCard(), indexOfCard()
                        // createDeck() : 덱 생성
                        // shuffleAllCardImageNumber() : 카드 이미지 숫자 배열 섞기
                        // createAllCard() : 모든 카드 객체 생성하고 배열에 저장
                        // selectRandomCard() : 랜덤 카드 선택
                        // showCardForHint() : 카드 한장 보여주기(힌트)
                        // isAllCardFront() : 모든 카드가 앞면인지 확인
                        // getLengthOfCardForHint() : 힌트 카드 배열 길이 반환
                        // indexOfCardForHint() : 매개변수로 전달 받은 위치의 카드 객체 반환
                        // getLengthCurrentPlayerSelectedCard() : 현재 플레이어가 선택한 카드를 저장한 배열의 길이를 반환
                        // indexOfCurrentPlayerSelectedCard() : 현재 플레이어가 선택한 카드를 저장한 배열에서 매개변수로 전달 받은 위치의 카드 객체 반환
                        // getLengthOfAllCard() : 카드 객체 배열의 길이를 반환
                        // indexOfCard() : 매개변수로 전달 받은 위치의 카드 객체 반환    


        // 전역 변수
        const gameModerator = new GameModerator();
        const gameHelper = new GameHelper();
        const deck = new Deck();
        const gameMessage = new GameMessage();
        
        let firstPlayer = null;
        let secondPlayer = null;
        let currentPlayer = null;

        window.onload = function() {
                alert('어서와 여늘이의 "Poker Game 🎰"은 처음이지?!💥');
                deck.shuffle();
                gameModerator.startGame();
        }

        // 플레이어가 룰 설명 버튼을 누른 경우
        function clickRuleButton() {
            // 게임 헬퍼가 룰을 설명한다.
            gameHelper.explainRule();
        }

        // 플레이어가 힌트 버튼을 누른 경우
        function clickHintButton() {
            // 게임 헬퍼가 힌트를 준다.
            gameHelper.giveHint();
        }

        // 사용자가 플레이어 생성 버튼을 누른 경우
        function clickCreatePlayerButton(inputTagPosion) {
            // 사용자가 입력한 닉네임을 저장하고 있는 input 태그 참조
            const input = document.getElementById(inputTagPosion);
            // 게임 헬퍼에게 넘겨주어 플레이어를 생성함 
            gameHelper.createPlayer(input);
        }
                
        
        // 사용자가 첫번째 플레이어의 게임 시작 버튼을 누른 경우 
        function selectFirstPlayer() {
            // 게임 진행자가 현재 플레이어를 첫 번째 플레이어로 설정 
            gameModerator.setFirstPlayerOnCurrentPlayer(); 
            // 게임 진행자가 게임판 업데이트함 
            gameModerator.updateGame(); 
            // 게임 시작 알림 메시지를 출력 
            alert(`${gameModerator.getCurrentPlayerName()}의 게임을 시작합니다.🔊`);
        }
        
        // 사용자가 두번째 플레이어의 게임 시작 버튼을 누른 경우 
        function selectSecondPlayer() {
            // 게임 진행자가 현재 플레이어를 두 번째 플레이어로 설정함 
            gameModerator.setSecondPlayerOnCurrentPlayer(); 
            // 게임 진행자가 게임판 업데이트함 
            gameModerator.updateGame(); 
            // 게임 시작 알림 메시지 출력 
            alert(`${gameModerator.getCurrentPlayerName()}의 게임을 시작합니다.🔊`); 
        }
        
        // 플레이어가 카드 태그를 선택한 경우
        function selectCardTag(selectCardTag) {
            // 게임 진행자가 적절히 처리해줌
            gameModerator.occurPlayerSelectCard(selectCardTag);
        }
        
        // 사용자가 결과 출력 버튼을 누른경우, 게임 매니저가 게임 결과 판단 
        function getGameResult() {
            // 게임 진행자는 게임 결과를 반환할 수 있는지 응답
            const answer = gameModerator.getGameResult();
            // 게임을 끝낸 경우 게임판 업데이트 
            if (answer) {
                // 플레이어 리셋 
                gameModerator.resetAllPlayer();
                // 게임 재시작 
                gameModerator.startGame(); 
            }
        }
        
        // 사용자와 소통하며 사용자를 돕는 객체 ✅
        function GameHelper() {
            // 랜덤 아바타 저장 
            const avators = ["🤹🏻‍♂️", "👨🏻‍🎤", "👩🏻‍🍳", "🦹🏻‍♂️", "🤵🏻‍♂️", "🧝🏻‍♀️", "🦸🏻‍♀️", "🧙🏻", "👰🏻‍♀️"];
            // 카드 개수 
            const NUMBER_OF_CARD = 52;

            // 난수 생성기 
            const randomGenerator = () => Math.floor(Math.random()*NUMBER_OF_CARD);

            // 룰 설명 
            this.explainRule = function() {
                // 📌 밑에 룰 업데이트 해야함, 게임 룰 변경됨 
                const ruleMessage = gameMessage.getGameRule();
                // 룰 메시지 보여주기 
                alert(ruleMessage);
            }

            // 플레이어 생성 
            this.createPlayer = function(input) {
                // 이미 모든 플레이어가 생성된 경우 
                if (firstPlayer !== null && secondPlayer !== null ) {
                    alert("이미 모든 플레이어가 생성되었습니다.💥");
                    gameMessage.createAllMessage();
                    return;
                }

                // 사용자가 입력한 닉네임 가져오기, 없으면 "익명플레이어"로 설정 
                const userName = input.value ? input.value : "익명플레이어";
                // 랜덤 아바타 뽑기
                const avator = this.selectRandomAvator();

                // 첫 번째 플레이어가 없는 경우, 첫 번째 플레이어로 등록 
                if (firstPlayer === null) {
                    firstPlayer = new Player(avator+userName);
                    alert(`첫번째 플레이어 "${firstPlayer.getName()}" 가 생성되었습니다.`);
                }
                // 두 번째 플레이어가 없는 경우, 두 번째 플레이어로 등록
                else if (secondPlayer === null) {
                    secondPlayer = new Player(avator+userName);
                    alert(`두번째 플레이어 "${secondPlayer.getName()}" 가 생성되었습니다.`);
                }

                // 게임 진행자가 플레이어 영역 업데이트 
                gameModerator.updateAllPlayerTag();
            }

            // 랜덤 아바타를 뽑음 
            this.selectRandomAvator = function() {
                // 아바타 배열 섞기 
                this.suffleAllAvator();
                return avators[0];
            }

            // 아바타 배열 섞기 
            this.suffleAllAvator = function() {
                for (let i=0; i<100; i++) {
                    avators.sort(() => Math.random() - 0.5);
                }
            }

            // 플레이어에게 힌트 보여주기 
            this.giveHint = function() {
                // 현재 플레이어가 설정되지 않은 경우 
                if (currentPlayer === null) {
                    alert("현재 플레이어가 설정되지 않았거나 플레이어를 생성하지 않았습니다. 다시 확인하고 플레이 해주세요.💥");
                    return;
                }
                // 덱에서 힌트 카드 보여주기 
                deck.showCardForHint();
                // 게임 진행자가 플레이어 영역 업데이트하기 
                gameModerator.updateAllPlayerTag();
            }
        }

        function Deck() {
            // 첫번째 카드의 이미지 숫자
            const FIRTS_CARD_IMAGE_NUMBER = 0;
            // 마지막 카드의 이미지 숫자 
            const LAST_CARD_IMAGE_NUMBER = 51;
            // 카드 개수 
            const NUMBER_OF_CARD = 52;
            // 최대 힌트 개수
            const MAX_HINT_COUNT = 3;
            // 한 판당 플레이어가 선택할 수 있는 카드 개수
            const MAX_NUMBER_OF_SELECTED_CARD = 2;

            // 카드 이미지 숫자 배열 
            const cardAllImageNumber = [];
            // 카드 객체 배열 
            const cards = [];
            // 힌트 카드 배열
            const selectedCardForHint = [];
            // 현재 플레이어가 선택한 카드 배열 
            const currentPlayerTwoSelectedCard = [];

            // 난수 생성기 
            const randomGenerator = () => Math.floor(Math.random()*NUMBER_OF_CARD);

            for (let i=FIRTS_CARD_IMAGE_NUMBER; i<=LAST_CARD_IMAGE_NUMBER; i++) {
                cardAllImageNumber.push(i);
            }

            // 덱 생성 
            this.createDeck = function() {
                // 카드 이미지 숫자 배열 섞기 
                this.shuffleAllCardImageNumber();
                // 모든 카드 객체 생성 
                this.createAllCard();
            }

            // 카드 이미지 숫자 배열 섞기 
            this.shuffleAllCardImageNumber = function() {
                for (let i=0; i<100; i++) {
                    cardAllImageNumber.sort(() => Math.random()-0.5);
                }
            }

            // 모든 카드 객체 생성 
            this.createAllCard = function() {
                // 카드 이미지 숫자 배열에 순서에 맞게 카드 객체 생성 
                for (number of cardAllImageNumber) {
                    cards.push(new Card(number));
                }
            }

            // 랜덤으로 카드 선택 
            this.selectRandomCard = function() {
                // 랜덤 숫자 
                const randomNumber = randomGenerator();
                // 카드 객체 배열 순회 
                for (card of cards) {
                    // 랜덤 숫자와 일치하는 카드 반환 
                    if (card.isSameCardImageNumber(randomNumber)) {
                        return card;
                    }
                }
            }

            // 힌트 카드 보여주기 
            this.showCardForHint = function() {
                // 현재 플레이어가 설정되지 않은 경우 
                if (currentPlayer === null) {
                    alert("플레이어를 생성하거나 현재 플레이어 시작버튼을 누르고 게임을 진행해주세요.💥");
                    return;
                }

                // 모든 카드가 이미 앞면인 경우 
                if (this.isAllCardFront()) {
                    alert("이미 모든 카드가 다 앞면입니다.💥");
                    return;
                }

                // 현재 플레이어의 힌트 개수가 남아있지 않은 경우 
                if (!currentPlayer.isLeftHintCount()) {
                    alert(`현재 플레이어인 "${currentPlayer.getName()}"는 힌트를 다 사용하셨습니다.💥`);
                    return;
                }

                // 힌트 카드를 찾아서 반환 
                while (true) {
                    // 랜덤 카드 선택 
                    const selectedCard = this.selectRandomCard();
                    // 해당 카드가 뒷 면인 경우
                    if (!selectedCard.isFront()) {
                        // 힌트 카드 배열에 저장 
                        selectedCardForHint.push(selectedCard);
                        // 해당 카드 뒤집기 
                        selectedCard.flip();
                        // 게임판 업데이트 
                        gameModerator.updateGameBoard();
                        // 현재 플레이어의 힌트 개수 1 감소
                        currentPlayer.decreaseHintCount();
                        return; 
                    }
                }
            }

            // 모든 카드가 앞면인지 확인 
            this.isAllCardFront = function() {
                // 카드 객체 배열 순회 
                for (card of cards) {
                    // 카드가 앞면이 아닌 경우 
                    if (!card.isFront()) {
                        return false;
                    }
                }

                return true;
            }

            // 힌트 카드 배열의 길이 반환 
            this.getLengthOfCardForHint = function() {
                return selectedCardForHint.length;
            }

            // 힌트 카드 배열에서 인덱스번째 카드 반환  
            this.indexOfCardForHint = function(index) {
                // 잘못된 인덱스 범위인 경우 
                if (!(0 <= index && index < this.getLengthOfCardForHint())) {
                    alert("잘못된 인덱스 범위입니다.");
                    return null;
                }

                return selectedCardForHint[index];
            }

            // 현재 플레이어가 선택한 카드 배열의 길이 반환 
            this.getLengthOfCurrentPlayerSelectedCard = function() {
                return currentPlayerTwoSelectedCard.length;
            }

            // 현재 플레이어가 선택한 배열에서 인덱스 번째 카드 반환 
            this.indexOfCurrentPlayerSelectedCard = function(index) {
                // 잘못된 인덱스 범위인 경우 
                if (!(0 <= index && index < this.getLengthOfCurrentPlayerSelectedCard())) {
                    alert("잘못된 인덱스 범위입니다.");
                    return null;
                }

                return currentPlayerTwoSelectedCard[index];
            }

            // 카드 객체 배열의 길이 반환 
            this.getLengthOfAllCard = function() {
                return cards.length;
            }

            // 카드 객체 배열에서 인덱스번째 카드 반환 
            this.indexOfCard = function(index) {
                // 잘못된 인덱스 범위 
                if (!(0 <= index && index < this.getLengthOfAllCard())) {
                    alert(`잘못된 인덱스 범위입니다. ${index}`);
                    return null;
                }

                return cards[index];
            }

            // 덱을 섞음 
            this.shuffle = function() {
                // 카드 객체 배열이 비어있는 경우 
                if (cards.length === 0) {
                    // 덱을 생성
                    this.createDeck();
                }

                // 모든 카드 객체를 초기화
                this.initAllCard();

                // 카드 객체 배열을 섞음 
                for (let i=0; i<100; i++) {
                    cards.sort(() => Math.random() - 0.5);
                }
            }

            // 모든 카드 객체를 초기화
            this.initAllCard = function() {
                // 카드 배열 순회
                for (card of cards) {
                    // 카드가 앞면인 경우 
                    if (card.isFront()) {
                        card.flip();
                    }
                }
            }

            // 카드 배열과 카드 이미지 숫자 배열을 연결 
            this.connectCardToCardImageNumber = function() {
                // 카드 이미지 숫자 배열 초기화 
                cardAllImageNumber.splice(0);

                // 카드 배열 순회 
                for (card of cards) {
                    // 카드의 이미지 숫자 값 넣어주기 
                    cardAllImageNumber.push(card.getCardImageNumber());
                }
            }

            // 덱 초기화 
            this.initDeck = function() {
                // 덱 섞기 
                this.shuffle();
                // 모든 카드 객체 초기화 
                this.initAllCard();
                // 카드 객체 배열과 카드 이미지 숫자 배열 연결, 일관성 유지
                this.connectCardToCardImageNumber();
                // 선택한 힌트 카드 배열 초기화 
                selectedCardForHint.splice(0);
                // 현재 플레이어가 선택한 두개의 카드를 저장하는 배열 초기화 
                currentPlayerTwoSelectedCard.splice(0);
            }
            
            // 카드 이미지 숫자에 대응하는 카드 객체 반환  
            this.findCard = function(cardImageNumber){
                // 카드 배열 순회 
                for (card of cards) {
                    if (card.isSameCardImageNumber(cardImageNumber)) {
                        return card;
                    }
                }
            }

            // 현재 플레이어가 선택한 카드 배열의 길이가 2인지 아닌지 판단 
            this.isCurrentPlayerSelectedTwoCard = function() {
                return currentPlayerTwoSelectedCard.length === MAX_NUMBER_OF_SELECTED_CARD ? true : false;
            }

            // 현재 플레이어가 선택한 카드를 '현재 플레이어가 선택한 두개의 카드를 저장한 배열'에 저장 
            this.pushCurrentPlayerSelectedCard = function(selectedCard) {
                // 이미 두 개를 선택한 경우 스킵 
                if (this.isCurrentPlayerSelectedTwoCard()) return;

                currentPlayerTwoSelectedCard.push(selectedCard);
            }

            // 현재 플레이어가 선택한 두개의 카드를 저장한 배열에서 카드 꺼내기 
            this.shiftCurrentPlayerSelectedCard = function() {
                // 카드가 저장되어 있지 않은 경우 스킵 
                if (currentPlayerTwoSelectedCard.length  === 0) return;
                return currentPlayerTwoSelectedCard.shift();
            }

            // 힌트 카드가 있는지 응답 
            this.isHintCard = function() {
                return selectedCardForHint.length > 0 ? true : false;
            }
        }

        // 1. 카드 객체 : 카드의 상태(앞면, 뒷면)과 카드 숫자 이미지를 저장, 그리고 그와 관련된 작업 묶음 
        function Card(cardImageNumber = 0, state = false) {
            var cardImageNumber = cardImageNumber; // 카드의 이미지 숫자 
            var state = state; // 카드의 상태값(앞면, 뒷면)

            // 카드가 앞면인지 응답
            this.isFront = function() {
                return state;
            }

            // 카드의 숫자 추출 
            this.getNumber = function() {
                return cardImageNumber % 13; 
            }

            // 카드의 모양 추출 
            this.getShape = function() {
                return Math.floor(cardImageNumber/13); 
            }

            // 카드의 색깔 추출  
            this.getColor = function() {
                return Math.floor(cardImageNumber/13)%2 === 0 ? "red" : "black";
            }

            // 카드의 이미지 숫자 반환 
            this.getCardImageNumber = function() {
                return cardImageNumber;
            }

            // 매개변수로 전달 받은 값과 얼마나 맞았는지 계산해서 반환 
            this.calculateSameCount = function(otherNumber, otherColor, otherShape) {
                return this.isSameNumber(otherNumber) + this.isSameColor(otherColor) + this.isSameShape(otherShape);
            }

            // 매개변수로 전달 받은 다른 카드의 숫자와 일치하는지 판단 
            this.isSameNumber = function(otherNumber) {
                return this.getNumber() === otherNumber ? 1 : 0;
            }

            // 매개변수로 전달 받은 다른 카드의 색깔과 일치하는지 판단 
            this.isSameColor = function(otherColor) {
                return this.getColor() === otherColor ? 1 : 0;
            }

            // 매개변수로 전달 받은 다른 카드의 모양과 일치하는지 판단 
            this.isSameShape = function(otherShape) {
                return this.getShape() === otherShape ? 1 : 0;
            }

            // 매개변수로 전달 받은 카드 이미지 숫자값과 맞는지 판단 
            this.isSameCardImageNumber = function(otherCardImageNumber) {
                return cardImageNumber === otherCardImageNumber ? true : false;
            }

            // 카드 뒤집기 
            this.flip = function() {
                state = !state;
            }
        }

        // 2. 플레이어 객체 : 이름, 점수, 남은 게임 횟수 저장하고 그와 관련된 작업을 묶음 
        function Player(name = "anonymous") {
            // 이름 
            var name = name; 
            // 점수 
            var score = 0; 
            // 게임 횟수
            var leftCount = 10; 
            // 게임 횟수
            var leftHintCount = 3;  

            // 자신이 승자인지, 패자인지, 무승부인지 판단(-1 : 자기가 이김, 0 : 무승부, 1 : 상대가 이김)
            this.isWinner = function(otherPlayerScore) {
                return score > otherPlayerScore ?  -1 : (score === otherPlayerScore ? 0: 1);
            }

            // 남은 횟수가 있는지 응답  
            this.isLeftCount =  function() {
                return leftCount > 0 ? true : false;
            }

            // 남은 힌트 횟수가 있는지 응답
            this.isLeftHintCount = function() {
                return leftHintCount > 0 ? true : false;
            }

            // 이름 반환 
            this.getName = function() {
                return name;
            }

            // 점수 반환 
            this.getScore = function() {
                return score;
            }

            // 남은 횟수 반환 
            this.getLeftCount = function() {
                return leftCount;
            }

            // 남은 힌트 횟수 반환
            this.getLeftHintCount = function() {
                return leftHintCount;
            }

            // 자신의 점수에 일정량만큼 더함 
            this.addScore = function(amount) {
                score += amount;
            }

            // 남은 횟수를 1 감소 
            this.decreaseCount = function() {
                if (leftCount > 0) {
                    leftCount--;
                }
            }

            // 남은 힌트 횟수를 1 감소
            this.decreaseHintCount = function() {
                if (leftHintCount > 0) {
                    leftHintCount--;
                }
            }

        }

        // 게임 결과 저장 객체 
        function GameMessage() {
            // 게임 결과 숫자 정보와 게임 결과 메시지와 매칭시켜 저장하는 맵 
            var map = new Map();
            var ruleMessage = ['안녕하세요"Poker Game 🎰"에 오신것을 환영합니다. 포커 게임을 시작하기 앞서 간단하게 룰을 설명하겠습니다. 각 플레이어는 5판의 판수와 3번의 힌트 기회가 주어집니다. 또한, 플레이어는 한판당 2개의 카드를 선택하면됩니다. 힌트의 경우 무작위로 뒷면의 카드 중 하나를 뒤집습니다. 이후에 카드를 뽑았을 때 해당 카드와 힌트 카드를 비교하여 점수를 합산합니다. 이때, 카드의 숫자, 모양, 색깔이 판단 기준이 되며 3중에 1개라도 맞추면 1점을 획득하고 2개를 맞추면 2점을 획득하며 두 카드는 앞면 상태로 놓여집니다.'];

            // 모든 게임 결과 메시지를 생성해서 저장 
            this.createAllMessage = function() {
                if (firstPlayer instanceof Player && secondPlayer instanceof Player) {
                    map.set(-1, `"${firstPlayer.getName()}"이 이겼습니다.🔊`); 
                    map.set(0, `"${firstPlayer.getName()}"와 "${secondPlayer.getName()}"의 점수가 같습니다. 무승부입니다.🔊`);
                    map.set(1, `${secondPlayer.getName()}가 이겼습니다.🔊`);
                    return;
                }
            }

            // 매개변수로 전달 받은 해당하는 게임 결과 메시지를 반화 
            this.translateGameMessage = function(gameResult) {
                return map.get(parseInt(gameResult));
            }

            // 게임 룰 메시지 반환 
            this.getGameRule = function() {
                return ruleMessage[0];
            }
        }

        // 3. 게임 매니저 객체 : 카드객체와 플레이어 객체를 포함해서, 전체 프로그램의 흐름을 담당
        function GameModerator() {

            // 현재 플레이어가 선택한 카드를 저장 
            var currentPlayerTwoSelectedCard = []; 
            // 게임 결과 맵에 저장 
            var gameResultMessage = new Map();


            // 게임이 시작했을 때 초기화면과 각 객체 상태 구성
            this.startGame = function() {
                // 덱에 있는 카드 섞기
                deck.shuffle();
                // 게임 메시지 셍성
                gameMessage.createAllMessage();
                // 모든 카드 태그 생성해서 추가
                this.updateAllCardTag();
                // 모든 플레이어 태그 붙이기
                this.updateAllPlayerTag();
            }

            // 게임판 업데이트 
            this.updateGame = function() {
                // 덱에 있는 카드 다시 섞기
                deck.shuffle();
                // 카드 태그 생성해서 붙이기
                this.updateAllCardTag();
                // 플레이어 태그 업데이트하기
                this.updateAllPlayerTag();
            }

            this.updateGameBoard = function() {
                // 카드 영역에 해당하는 자식 노드들 참조 
                const cardAreaChildren = document.getElementById("cardArea").children;

                // 각 자식 노드에 접근 
                for (child of cardAreaChildren) {
                    // 덱에서 모든 카드를 참조 
                    for (let i=0; i<deck.getLengthOfAllCard(); i++) {
                        // 각 카드에 접근 
                        const card = deck.indexOfCard(i);
                        if (card === null) return;
                        // 해당 카드와 자식 노드의 카드 이미지 숫자와 같은 경우, 즉 같은 카드인 경우 
                        if (card.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                            // 해당 카드가 앞면인 경우 
                            if (card.isFront()) {
                                // 앞면으로 돌려주기 
                                child.setAttribute("src", `img/card_img/${card.getCardImageNumber()}.png`);
                            }
                        }
                    }
                }
            }


            // 모든 게임 결과 메시지를 생성해서 맵에 게임 결과 숫자와 매핑하여 저장 
            this.createGameResultMessage = function() {
                // 첫 번째 플레이어와 두 번재 플레이어가 존재하는 경우 
                if (firstPlayer instanceof Player && secondPlayer instanceof Player) {
                    // 각 게임 결과 숫자값과 그에 상응하는 메시지를 저장
                    // -1, 첫 번째 플레이어가 이김 
                    gameResultMessage.set(-1, `"${firstPlayer.getName()}"이 이겼습니다.🔊`); 
                    // 0, 무승부 
                    gameResultMessage.set(0, `"${firstPlayer.getName()}"와 "${secondPlayer.getName()}"의 점수가 같습니다. 무승부입니다.🔊`);
                    // 1, 두 번째 플레이어가 이김 
                    gameResultMessage.set(1, `${secondPlayer.getName()}가 이겼습니다.🔊`);
                }
            }

            // 모든 카드 객체의 태그를 생성해서 추가 
            this.updateAllCardTag = function() {
                // 카드 영역 태그 참조 
                const cardArea = document.getElementById("cardArea");
                // 해당 영역 내부 HTML 초기화 
                cardArea.innerHTML = "";

                // 덱에서 모든 카드 객체 참조 
                for (let i=0; i<deck.getLengthOfAllCard(); i++) {
                    // 각 카드에 접근 
                    const card = deck.indexOfCard(i);
                    // 이미지 태그 생성 
                    const imgTag = document.createElement("img");

                    // 카드가 앞면인 경우 
                    if (card.isFront()) {
                        // 앞면으로 보여주기 
                        imgTag.setAttribute("src", `img/card_img/${card.getCardImageNumber()}.png`);
                    } else {
                        // 그게 아니면, 뒷면으로 보여주기 
                        imgTag.setAttribute("src", `img/card_img/back.png`);
                    }

                    // 태그에 카드 이미지 숫자 저장 
                    imgTag.setAttribute("data-number", card.getCardImageNumber());
                    // 태그에 함수 연결 
                    imgTag.setAttribute("onclick", "selectCardTag(this)");
                    // 이미지 태그 카드 영역 태그에 추가 
                    cardArea.appendChild(imgTag);
                }
            }

            // 모든 플레이어의 태그 업데이트 
            this.updateAllPlayerTag = function() {
                // 첫 번째 플레이어 영역과 두 번째 플레이어 영역 참조 
                const firstPlayerArea = document.getElementById("firstPlayerArea");
                const secondPlayerArea = document.getElementById("secondPlayerArea");

                // 첫 번재 플레이어와 두 번재 플레이어 영역의 내부 HTML 초기화
                firstPlayerArea.innerHTML = "";
                secondPlayerArea.innerHTML = "";

                // 첫 번째 플레이어가 생성된 경우 
                if (firstPlayer instanceof Player) {
                    // 첫 번째 플레이어 영역 업데이트
                    firstPlayerArea.innerHTML = `<h3 class="title">${firstPlayer.getName()}</h3>`;
                    firstPlayerArea.innerHTML += `<br>`;
                    firstPlayerArea.innerHTML += `<p class="record"><strong>👉 남은 횟수-${firstPlayer.getLeftCount()}, 현재 점수-${firstPlayer.getScore()}, 남은 힌트-${firstPlayer.getLeftHintCount()} 👯‍♀️</strong></p>`;    
                }
                
                // 두 번째 플레이어가 생성된 경우
                if (secondPlayer instanceof Player) {
                    // 두 번째 플레이어 영역 업데이트 
                    secondPlayerArea.innerHTML = `<h3 class="title">${secondPlayer.getName()}</h3>`
                    secondPlayerArea.innerHTML += `<br>`;
                    secondPlayerArea.innerHTML += `<p class="record"><strong>👉 남은 횟수-${secondPlayer.getLeftCount()}, 현재 점수-${secondPlayer.getScore()}, 남은 힌트-${secondPlayer.getLeftHintCount()} 👯‍♀️</strong></p>`;
                }
            }

            
            // 첫번째 플레이어를 현재 플레이어로 설정 
            this.setFirstPlayerOnCurrentPlayer = function() {
                // 첫 번재 플레이어가 생성되지 않은 경우 
                if (firstPlayer === null) {
                    alert('첫번째 플레이어를 생성하고 "플레이어1 시작"버튼을 눌러주세요.💥');
                    return;
                }

                // 첫 번째 플레이어를 현재 플레이어로 설정 
                currentPlayer = firstPlayer;
            }

            // 두번째 플레이어를 현재 플레이어로 설정 
            this.setSecondPlayerOnCurrentPlayer = function() {
                // 두 번째 플레이어가 생성되지 않은 경우 
                if (secondPlayer === null) {
                    alert('두번째 플레이어를 생성하고 "플레이어2 시작" 버튼을 눌러주새요.💥');
                    return;
                }

                // 두 번재 플레이어를 현재 플레이어로 설정 
                currentPlayer = secondPlayer;
            }

            // 현재 플레이어가 카드를 선택했을 때 처리해줘야 할 작업 
            this.occurPlayerSelectCard = function(selectedCardTag) {
                // 현재 플레이어 객체가 설정되지 않은 경우 
                if (!(currentPlayer instanceof Player)) { 
                    alert("플레이어 시작 버튼을 누르고 게임을 진행하세요.🔊");
                    return;
                }

                // 현재 플레이어가 모든 횟수를 다 소진한 경우
                if (!currentPlayer.isLeftCount()) { 
                    // 현재 상태 알려주기 
                    alert(`"${currentPlayer.getName()}"의 게임 횟수가 ${currentPlayer.getLeftCount()}입니다.🔊`);
                    alert(`"${currentPlayer.getName()}"의 점수는 ${currentPlayer.getScore()}입니다.🔊`);
                    // 태그 업데이트 
                    this.updateAllPlayerTag();
                    return;
                }

                // 플레이어가 선택한 태그에 대응되는 카드 가져옴 
                const currentPlayerSelectedCard = this.findSelectedCardByTag(selectedCardTag);
                if (currentPlayerSelectedCard.isFront()) {
                    // 앞면인 경우 건너뛰기
                    return; 
                }

                // 첫번째 카드와 힌트 카드 비교, 번째 카드와 힌트 카드 비교 
                let sameCountForFirstSelectedCardWithHint = 0;
                let sameCountForSecondSelectecCardWithHint = 0;
                
                // 힌트 카드와 이전에 선택한 카드 먼저 비교 
                for (let i=0; i<deck.getLengthOfCardForHint(); i++) {
                    // 힌트 카드 하나씩 참조
                    const cardForHint = deck.indexOfCardForHint(i);
                    // 현재 플레이어가 선택한 카드 하나씩 참조 
                    for (let j=0; j<deck.getLengthOfCurrentPlayerSelectedCard(); j++) {
                        const selectedCard = deck.indexOfCard(j);
                        // 서로 일치하는 갯수 카운트 
                        const amount = selectedCard.calculateSameCount(cardForHint.getNumber(), cardForHint.getColor(), cardForHint.getShape());
                        
                        // 첫 번째 카드인 경우 "첫 번째 카드와 힌트 카드 비교"에 기록
                        if (j === 0) {
                            sameCountForFirstSelectedCardWithHint += amount;
                        } 
                        // 두 번째 카드인 경우 "두 번째 카드와 힌트 카드 비교"에 기록
                        else {
                            sameCountForSecondSelectecCardWithHint += amount;
                        }

                        // 스코어 업데이트
                        currentPlayer.addScore(amount);
                        // 태그 업데이트 
                        this.updateAllPlayerTag();
                    }
                }

                // 두개의 카드를 선택했으면 서로 비교 
                if (deck.isCurrentPlayerSelectedTwoCard()) {
                    // 두개의 카드 서로 일치하는 갯수 카운트 및 뒤집기 
                    const amount = this.getSameAmountBetweenTwoSelectedCard(sameCountForFirstSelectedCardWithHint, sameCountForSecondSelectecCardWithHint);
                    // 스코어 업데이트 
                    currentPlayer.addScore(amount);
                    // 판수 업데이트 
                    currentPlayer.decreaseCount();
                    // 태그 업데이트 
                    this.updateAllPlayerTag();
                    return;
                }

                // 카드 객체에 현재 플레이어가 선택한 카드 저장 
                deck.pushCurrentPlayerSelectedCard(currentPlayerSelectedCard);
                // 선택한 카드 보여주기
                this.showSelectedCard(selectedCardTag);
            }

            // 현재 플레이어가 선택한 2개의 카드 중에서 무엇이 맞는지 숫자로 반환(숫자, 색깔, 도형)
            this.getSameAmountBetweenTwoSelectedCard = function(sameAmountWithHintForFirstCard, sameAmountWithHintForSecondCard) {
                // 햔재 플레이어가 선택한 카드 한장 빼내기(첫 번째 카드)
                const firstSelectedCard = deck.shiftCurrentPlayerSelectedCard();
                // 현재 플레이어가 선택한 카드 한장 빼내기(두 번째 카드)
                const secondSelectedCard = deck.shiftCurrentPlayerSelectedCard();
                // 서로 얼마나 맞는지 계산 
                const amount = firstSelectedCard.calculateSameCount(secondSelectedCard.getNumber(), secondSelectedCard.getColor(), secondSelectedCard.getShape());
                // 해당 카드 객체에 해당하는 태그의 속성 업데이트(뒷면으로 설정)  
                const cardAreaChildren = document.getElementById("cardArea").children;   

                // 선택한 두 카드의 숫자, 컬러, 모양 안 맞은 경우
                if (amount === 0) { 
                    // 모든 힌트 카드와 선택한 두카드가 서로 일치하는게 하나도 없을 때, 모두 뒤집기
                    if (sameAmountWithHintForFirstCard === 0 && sameAmountWithHintForSecondCard === 0) {
                        firstSelectedCard.flip(); // 첫번째 카드 뒤집기 
                        secondSelectedCard.flip(); // 두번째 카드 뒤집기 
                        for (child of cardAreaChildren) {
                            if (firstSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number"))) || secondSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            } 
                        }
                    } 
                    // 모든 힌트 카드와 선택한 두 번째 카드가 서로 일치하는 게 없을 때, 두 번째 카드만 뒤집기
                    else if (sameAmountWithHintForFirstCard !== 0 && sameAmountWithHintForSecondCard === 0) {
                        secondSelectedCard.flip();
                        for (child of cardAreaChildren) {
                            if (secondSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            }
                        }
                    }
                    // 모든 힌트 카드와 선택한 첫 번째 카드가 서로 일치하는 게 없을 때, 첫 번째 카드만 뒤집기
                    else if (sameAmountWithHintForFirstCard === 0 && sameAmountWithHintForSecondCard !== 0) {
                        firstSelectedCard.flip();
                        for (child of cardAreaChildren) {
                            if (firstSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            }
                        }
                    }
                } 
                
                // 두 카드가 일치하는 갯수 반환 
                return amount;
            }


            // 선택한 태그와 매칭되는 카드 객체 찾기 
            this.findSelectedCardByTag = function(selectedCardTag) {
                const selectedCardImageNumber = parseInt(selectedCardTag.getAttribute("data-number"));
                return deck.findCard(selectedCardImageNumber);
            }


            // 선택한 카드를 화면에 보여줌 
            this.showSelectedCard = function(selectedCardTag) {
                // 현재 플레이어의 게임 횟수가 0인 경우 
                if (!currentPlayer.isLeftCount()) return; 
                // 현재 플레이어가 선택한 태그에 해당하는 카드 객체 찾기 
                const currentPlayerSelectedCard = this.findSelectedCardByTag(selectedCardTag); 
                
                // 카드 객체가 앞면이면 스킵 
                if (currentPlayerSelectedCard.isFront()) return; 
                // 카드 객체가 뒷면이였으면, 돌리기 
                currentPlayerSelectedCard.flip(); 
                // 카드 태그의 속성 업데이트 
                selectedCardTag.setAttribute("src", `img/card_img/${currentPlayerSelectedCard.getCardImageNumber()}.png`);
            }

            // 게임 결과를 숫자로 조회 
            this.getGameResult = function() {
                // 플레이어의 게임 횟수가 남아있는 경우, 스킵 
                if (firstPlayer.isLeftCount() || secondPlayer.isLeftCount()) { 
                    alert(`아직 플레이어의 판수가 남아있습니다. 모든 플레이어의 판수 다 끝나면 요청해주세요.🔊`);
                    return false;
                }

                // 게임 결과를 숫자로 반환
                const result = firstPlayer.isWinner(secondPlayer.getScore()); 
                // 숫자 결과를 문자 결과로 반환해서 출력 
                this.notifyGameResult(result); 
                return true;
            }

            // 게임 결과 메시지로 발표 
            this.notifyGameResult = function(result) {
                // 두 플레이어가 생성된 경우 게임 결과 메시지 생성 
                if (firstPlayer !== null && secondPlayer !== null) {
                    gameMessage.createAllMessage();
                }

                // 게임 결과 숫자를 메시지로 반환
                const resultMessage = gameMessage.translateGameMessage(result);
                // 게임 결과 메시지 알림 
                alert(resultMessage);
            }

            // 현재 플레이어의 이름을 반환 
            this.getCurrentPlayerName = function() {
                return currentPlayer.getName();
            }

            // 모든 플레이어를 초기화 
            this.resetAllPlayer = function() {
                alert("플레이어의 기록을 초기화합니다.💥");
                // 첫 번째와 두 번째 그리고 현재 플레이어 삭제 
                firstPlayer = null; 
                secondPlayer = null; 
                currentPlayer = null;
            }
        }

    </script>
</body>
</html>
