<!--카드 게임-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            background-image: url("img/poker.png");
        }
        img {
            margin-top: 5px;
            margin-bottom: 5px;
            margin-left: 2px;
            margin-right: 2px;
            width: 100px;
            height: 100px;
        }
        #container {
            display: grid;
            grid-template-columns: 1fr 3fr 1fr;
        }
        #gameArea {
            text-align: center;
            display: inline;
            height: 500px;
            width: 500px;
            position: static;
            margin-top: 50px;
            margin-bottom: 50px;
            margin-left: 10px;
            margin-right: 10px;
        }
        #btnArea {
            text-align: center
        }
        button {
            display: inline-block;
            margin: 0;
            padding: 0;
            position: relative;
            border: none;
            min-width: 200px;
            min-height: 50px;
            background: linear-gradient(
                90deg,
                rgba(129, 230, 217, 1) 0%,
                rgba(79, 209, 197, 1) 100%
            );
            border-radius: 1000px;
            color: darkslategray;
            cursor: pointer;
            box-shadow: 12px 12px 24px rgba(79, 209, 197, 0.64);
            font-weight: 700;
            transition: 0.3s;
        }
        #firstPlayerArea {
            text-align: center;
            display: inline;
            float : left;
            margin-top: 3em;
            margin-bottom: 3em;
        }
        #secondPlayerArea {
            text-align: center;
            display: inline;
            float : right;
            margin-top: 3em;
            margin-bottom: 3em;
        }
        #playerRecordArea {
            display: inline;
        }
        #playerArea {
            display: inline;
        }

        .title {
            color: white;
            font-style: italic;
            font-size : 25px;
            display: inline;
        }

        #leftPlayerArea {
            float : left;
        }
        #rightPlayerArea {
            float : right;
        }

        .record {
            color : yellow;
            font-style: oblique;
        }
        
    </style>
</head>
<body>
    <h1 style="text-align: center; color : white">Poker Game 🎰</h1>
    <div style="text-align: center; color : white;">
        <input id="userInformation" type="text">
        <button onclick="clickCreatePlayerButton('userInformation')">Create Your Player!!🤹🏻‍♂️</button>
    </div>
    

    <!-- <span id="leftPlayerArea">
        <div id="firstPlayerArea">
            <h2 class="title"></h2>
            <br>
        </div>
    </span>
    <span id="rightPlayerArea">
        <div id="secondPlayerArea">
            <h2 class="title"></h2>
            <br>
        </div>
    </span> -->
    <span>
        <div id="firstPlayerArea"></div>
        <div id="secondPlayerArea"></div>
    </span>

    <br>
    <br>
    <br>
    <br>
    <br>
    <br>


        
    </div>

    <div id="gameArea">
        <div id="cardArea"></div>
    </div>

    <br>
    <br>
    <br>
    
    <div id="btnArea">
        <button onclick="selectFirstPlayer()">
            플레이어1 시작
        </button>
    
        <button onclick="getGameResult()">
            게임 결과 출력 
        </button>
    
        <button onclick="selectSecondPlayer()">
            플레이어2 시작
        </button>
        <button onclick="clickHintButton()">
            힌트
        </button>
        <button onclick="clickRuleButton()">
            룰 설명
        </button>
    </div>

    <script>
        // 추가 된 기능 
            // 1. 게임 룰 설명
            // 2. 힌트 2번 주기
            // 3. 사용자가 직접 이름 지정
            
        // 3차 객체 설계도 
            // 객체 설계 
                // 1. 카드 객체 ✅
                    // iv -> cardImageNumber, state 
                        // cardImageNumber : 카드 이미지 숫자, 숫자형 
                        // state : 상태, 앞면인지 뒷면인지, boolean 

                    // im -> getNumber(), getShape(), getColor(), getCardImageNumber(), isFront(), isSameNumber(), isSameColor(), isSameShape(), isSameCardImageNumber(), flip()
                        // getNumber() : 카드 숫자 추출
                        // getShape() : 카드 모양 추출
                        // getColor() : 카드 색깔 추출 
                        // getCardImageNumber() : 카드 이미지 숫자 반환 
                        // isFront() : 카드가 앞면인지 응답
                        // isSameNumber() : 매개변수로 전달 받은 카드의 숫자와 같은지 응답 
                        // isSameColor() : 매개변수로 전달 받은 카드의 색깔과 같은지 응답 
                        // isSameShape() : 매개변수로 전달 받은 카드의 모양과 같은지 응답 
                        // calculateSmaeCount() : 매개변수로 전달 받은 값들과 얼마나 맞았는지 계산해서 응답 
                        // isSameCardImageNumber() : 매개변수로 전달 받은 카드의 이미지 숫자와 같은지 응답  
                        // flip() : 카드 상태 반전 
                    

                

                // 2. 플레이어 객체 ✅
                    // iv -> name, score, leftCount
                        // name : 이름, 문자열
                        // score : 점수, 숫자형 
                        // leftCount : 남은 판수, 숫자형  

                    // im -> getName(), getScore(), getLeftCount(), isWinner(), isLeftCount(), addScore(), decreaseCount()
                        // getName() : 이름 반환
                        // getScore() : 점수 반환
                        // getLeftCount() : 남은 횟수 반환
                        // isWinner() : 자신이 승자인지, 패자인지, 무승부인지 응답
                        // isLeftCount() : 남은 횟수가 있는지 응답
                        // addScore() : 자신의 점수에 일정량 더함
                        // decreaseCount() : 남은 횟수를 1 감소함
            
                // 3. 게임 진행자 객체 ✅
                    // iv -> cardImageNumbers, FIRST_CARD_IMAGE_NUMBER, LAST_CARD_IMAGE_NUMBER, cards, currentPlayerSelectedTwoCard, firstPlayer, secondPlayer, currentPlayer, gameResultMessage
                        // cardImageNumbers : 카드 이미지 숫자를 저장하는 배열
                        // FIRST_CARD_IMAGE_NUMBER, LAST_CARD_IMAGE_NUMBER : 카드 이미지 숫자의 시작과 끝 숫자
                        // cards : 카드 객체 저장하는 배열
                        // currentPlayerSelectedTwoCard : 현재 플레이어가 선택한 2개의 카드를 저장하는 배열
                        // firstPlayer, secondPlayer, currentPlayer : 첫번째 플레이어 객체, 두번째 플레이어 객체, 현재 게임을 진행하는 플레이어 객체
                        // gameResultMessage : 게임 결과 숫자와 게임 결과 메시지를 매칭시켜서 저장한 맵

                    // im -> appendAllCardTag(), appendAllPlayerTag(), getCurrentPlayer(), getGameResult(), getSameAmountBetweenTwoSelectedCard(), 
                           // createAllCard(), createAllPlayer(), createGameResultMessage(), updateGame(), updateAllPlayerTag(), occurPlayerSelectCard(),
                           // startGame(), suffleAllCard(), suffleAllCardImageNumber(), setFirstPlayerOnCurrentPlayer(), setSecondPlayerOnCurrentPlayer(), showSelectedCard(),
                           // hideAllFrontCard(), findSelectedCardByTag(), notifyGameResult(), resetAllPlayer()
                        
                            // appendAllCardTag() : 모든 카드 객체의 태그를 생성해서 추가
                            // appendAllPlayerTag() : 모든 플레이어 객체의 태그를 생성해서 추가

                            // getCurrentPlayer() : 현재 플레이어를 반환
                            // getGameResult() : 현재 게임 결과 숫자를 반환
                            // getSameAmountBetweenTwoSelectedCard() : 현재 플레이어가 선택한 2개의 카드 중에서 무엇이 맞는지 반환(숫자, 색깔, 도형)

                            // createAllCard() : 모든 카드 객체를 생성
                            // createAllPlayer() : 모든 플레이어 객체를 생성
                            // createGameResultMessage() : 모든 게임 결과 메시지를 생성해서 맵에 게임 결과 숫자와 매핑하여 저장

                            // updateGame() : 게임판 업데이트
                            // updateAllPlayerTag() : 모든 플레이어의 태그 업데이트

                            // occurPlayerSelectCard() : 플레이어가 카드를 선택했을 때 처리해줘야 할 작업

                            // startGame() : 게임이 시작됐을 때 초기 화면, 상태 구성
                            // suffleAllCard() : 모든 카드 객체를 섞음
                            // suffleAllCardImageNumber() : 모든 카드 이미지 숫자를 섞음
                            // setFirstPlayerOnCurrentPlayer(), setSecondPlayerOnCurrentPlayer() : 현재 플레이어 세팅
                            // showSelectedCard() : 선택한 카드를 화면에 보여줌

                            // hideAllFrontCard() : 앞면인 카드를 모두 뒷면으로 돌려줌

                            // findSelectedCardByTag() : 선태한 태그와 매칭되는 카드 객체 찾기

                            // notifyGameResult() : 게임 결과 발표

                            // resetAllPlayer() : 모든 플레이어 초기화 

        // 전역 변수
        const gameModerator = new GameModerator();
        const gameHelper = new GameHelper();
        const deck = new Deck();
        const gameResult = new GameResult();
        
        let firstPlayer = null;
        let secondPlayer = null;
        let currentPlayer = null;

        window.onload = function() {
                alert('어서와 여늘이의 "Poker Game 🎰"은 처음이지?!💥');
                deck.shuffle();
                gameModerator.startGame();
        }

        // 플레이어가 룰 설명 버튼을 누른 경우
        function clickRuleButton() {
            // 게임 헬퍼가 룰을 설명한다.
            gameHelper.expalinRule();
        }

        // 플레이어가 힌트 버튼을 누른 경우
        function clickHintButton() {
            // 게임 헬퍼가 힌트를 준다.
            gameHelper.giveHint();
        }

        // 사용자가 플레이어 생성 버튼을 누른 경우
        function clickCreatePlayerButton(inputTagPosion) {
            // 사용자가 입력한 닉네임을 저장하고 있는 input 태그 참조
            const input = document.getElementById(inputTagPosion);
            // 게임 헬퍼에게 넘겨주어 플레이어를 생성함 
            gameHelper.createPlayer(input);
        }
                
        
        // 사용자가 첫번째 플레이어의 게임 시작 버튼을 누른 경우 
        function selectFirstPlayer() {
            // 게임 진행자가 현재 플레이어를 첫 번째 플레이어로 설정 
            gameModerator.setFirstPlayerOnCurrentPlayer(); 
            // 게임 진행자가 게임판 업데이트함 
            gameModerator.updateGame(); 
            // 게임 시작 알림 메시지를 출력 
            alert(`${gameModerator.getCurrentPlayerName()}의 게임을 시작합니다.🔊`);
        }
        
        // 사용자가 두번째 플레이어의 게임 시작 버튼을 누른 경우 
        function selectSecondPlayer() {
            // 게임 진행자가 현재 플레이어를 두 번째 플레이어로 설정함 
            gameModerator.setSecondPlayerOnCurrentPlayer(); 
            // 게임 진행자가 게임판 업데이트함 
            gameModerator.updateGame(); 
            // 게임 시작 알림 메시지 출력 
            alert(`${gameModerator.getCurrentPlayerName()}의 게임을 시작합니다.🔊`); 
        }
        
        // 플레이어가 카드 태그를 선택한 경우
        function selectCardTag(selectCardTag) {
            // 게임 진행자가 적절히 처리해줌
            gameModerator.occurPlayerSelectCard(selectCardTag);
        }
        
        // 사용자가 결과 출력 버튼을 누른경우, 게임 매니저가 게임 결과 판단 
        function getGameResult() {
            // 게임 진행자는 게임 결과를 반환할 수 있는지 응답
            const answer = gameModerator.getGameResult();
            // 게임을 끝낸 경우 게임판 업데이트 
            if (answer) {
                // 플레이어 리셋 
                gameModerator.resetAllPlayer();
                // 게임 재시작 
                gameModerator.startGame(); 
            }
        }
        
        // 사용자와 소통하며 사용자를 돕는 객체 ✅
        function GameHelper() {
            // 랜덤 아바타 저장 
            const avators = ["🤹🏻‍♂️", "👨🏻‍🎤", "👩🏻‍🍳", "🦹🏻‍♂️", "🤵🏻‍♂️", "🧝🏻‍♀️", "🦸🏻‍♀️", "🧙🏻", "👰🏻‍♀️"];
            const NUMBER_OF_CARD = 52;
            
            // 난수 생성기 
            const randomGenerator = () => Math.floor(Math.random()*NUMBER_OF_CARD);

            // 룰 설명 
            this.expalinRule = function() {
                // 📌 밑에 룰 업데이트 해야함, 게임 룰 변경됨 
                let message = "";
                message += '안녕하세요"Poker Game 🎰"에 오신것을 환영합니다.'; 
                message += ' 포커 게임을 시작하기 앞서 간단하게 룰을 설명하겠습니다.';
                message += ' 각 플레이어는 5판의 판수와 3번의 힌트 기회가 주어집니다.';
                message += ' 또한, 플레이어는 한판당 2개의 카드를 선택하면됩니다.';
                message += ' 이때, 카드의 숫자, 모양, 색깔이 판단 기준이 되며 3중에 1개라도 맞추면 1점을 획득하고 2개를 맞추면 2점을 획득하며 두 카드는 앞면 상태로 놓여집니다.';
                message += ' 하지만 모두 못 맞출 경우 카드는 다시 뒤집힙니다. 그리고 모든 플레이어가 모두 플레이한 경우 게임 결과 출력 버튼을 통해 게임 결과를 확인하실 수 있습니다.';

                // 룰 메시지 보여주기 
                alert(message);
            }

            // 플레이어 생성 
            this.createPlayer = function(input) {
                // 이미 모든 플레이어가 생성된 경우 
                if (firstPlayer !== null && secondPlayer !== null ) {
                    alert("이미 모든 플레이어가 생성되었습니다.💥");
                    gameResult.createAllMessage();
                    return;
                }

                // 사용자가 입력한 닉네임 가져오기, 없으면 "익명플레이어"로 설정 
                const userName = input.value ? input.value : "익명플레이어";
                // 랜덤 아바타 뽑기
                const avator = this.selectRandomAvator();

                // 첫 번째 플레이어가 없는 경우, 첫 번째 플레이어로 등록 
                if (firstPlayer === null) {
                    firstPlayer = new Player(avator+userName);
                    alert(`첫번째 플레이어 "${firstPlayer.getName()}" 가 생성되었습니다.`);
                }
                // 두 번째 플레이어가 없는 경우, 두 번째 플레이어로 등록
                else if (secondPlayer === null) {
                    secondPlayer = new Player(avator+userName);
                    alert(`두번째 플레이어 "${secondPlayer.getName()}" 가 생성되었습니다.`);
                }

                // 게임 진행자가 플레이어 영역 업데이트 
                gameModerator.updateAllPlayerTag();
            }

            // 랜덤 아바타를 뽑음 
            this.selectRandomAvator = function() {
                // 아바타 배열 섞기 
                this.suffleAllAvator();
                return avators[0];
            }

            // 아바타 배열 섞기 
            this.suffleAllAvator = function() {
                for (let i=0; i<100; i++) {
                    avators.sort(randomGenerator);
                }
            }

            // 플레이어에게 힌트 보여주기 
            this.giveHint = function() {
                // 현재 플레이어가 설정되지 않은 경우 
                if (currentPlayer === null) {
                    alert("현재 플레이어가 설정되지 않았거나 플레이어를 생성하지 않았습니다. 다시 확인하고 플레이 해주세요.💥");
                    return;
                }
                // 덱에서 힌트 카드 보여주기 
                deck.showCardForHint();
                // 게임 진행자가 플레이어 영역 업데이트하기 
                gameModerator.updateAllPlayerTag();
            }
        }

        function Deck() {

            const FIRTS_CARD_IMAGE_NUMBER = 0;
            const LAST_CARD_IMAGE_NUMBER = 51;
            const NUMBER_OF_CARD = 52;
            const LAST_CARD_INDEX = NUMBER_OF_CARD-1;
            const MAX_HINT_COUNT = 3;

            const cardAllImageNumber = [];
            const cards = [];
            const selectedCardForHint = [];
            const currentPlayerTwoSelectedCard = [];

            let cardIndex = 0;
            let cardForHintIndex = 0;
            let currentPlayerSelectedCardIndex = 0;

            const randomGenerator = () => Math.floor(Math.random()*NUMBER_OF_CARD);

            for (let i=FIRTS_CARD_IMAGE_NUMBER; i<=LAST_CARD_IMAGE_NUMBER; i++) {
                cardAllImageNumber.push(i);
            }

            this.createDeck = function() {
                this.shuffleAllCardImageNumber();
                this.createAllCard();
            }

            this.shuffleAllCardImageNumber = function() {
                for (let i=0; i<100; i++) {
                    cardAllImageNumber.sort(() => Math.random()-0.5);
                }
            }

            this.createAllCard = function() {
                for (number of cardAllImageNumber) {
                    cards.push(new Card(number));
                }
            }

            this.selectRandomCard = function() {
                const randomNumber = randomGenerator();
                for (card of cards) {
                    if (card.isSameCardImageNumber(randomNumber)) {
                        return card;
                    }
                }
            }

            this.showCardForHint = function() {
                if (currentPlayer === null) {
                    alert("플레이어를 생성하거나 현재 플레이어 시작버튼을 누르고 게임을 진행해주세요.💥");
                    return;
                }

                if (this.isAllCardFront()) {
                    alert("이미 모든 카드가 다 앞면입니다.💥");
                    return;
                }

                if (!currentPlayer.isLeftHintCount()) {
                    alert(`현재 플레이어인 "${currentPlayer.getName()}"는 힌트를 다 사용하셨습니다.💥`);
                    return;
                }

                while (true) {
                    const selectedCard = this.selectRandomCard();
                    if (!selectedCard.isFront()) {
                        selectedCardForHint.push(selectedCard);
                        selectedCard.flip();
                        gameModerator.updateGameBoard();
                        currentPlayer.decreaseHintCount();
                        return; 
                    }
                }
            }

            this.isAllCardFront = function() {
                for (card of cards) {
                    if (!card.isFront()) {
                        return false;
                    }
                }

                return true;
            }

            this.getLengthOfCardForHint = function() {
                return selectedCardForHint.length;
            }

            this.indexOfCardForHint = function(index) {
                if (index >= this.getLengthOfCardForHint()) {
                    alert("잘못된 인덱스 범위입니다.");
                    return null;
                }

                return selectedCardForHint[index];
            }

            this.getLengthOfCurrentPlayerSelectedCard = function() {
                return currentPlayerTwoSelectedCard.length;
            }

            this.indexOfCurrentPlayerSelectedCard = function(index) {
                if (index >= this.getLengthOfCurrentPlayerSelectedCard()) {
                    alert("잘못된 인덱스 범위입니다.");
                    return null;
                }

                return currentPlayerTwoSelectedCard[index];
            }

            this.getLengthOfAllCard = function() {
                return cards.length;
            }

            this.indexOfCard = function(index) {
                if (index >= this.getLengthOfAllCard()){
                    alert("잘못된 인덱스 범위입니다.");
                    return null;
                }

                return cards[index];
            }

            this.selectCardInOrder = function() {
                if (cardIndex <= LAST_CARD_IMAGE_NUMBER) {
                    return cards[cardIndex++];
                } 

                cardIndex = 0;
                return cards[cardIndex++];
            }

            this.selectCurrentPlayerTwoSelectedCard = function() {
                if (currentPlayerTwoSelectedCard.length === 0) {
                    alert("선택한 카드가 없습니다.");
                    return null;
                }

                const card = currentPlayerTwoSelectedCard[Math.floor(currentPlayerSelectedCardIndex/currentPlayerTwoSelectedCard.length)];
                currentPlayerSelectedCardIndex++;
                return card;
            }



            this.shuffle = function() {
                if (cards.length === 0) {
                    this.createDeck();
                }

                this.initAllCard();

                for (let i=0; i<100; i++) {
                    cards.sort(() => Math.random() - 0.5);
                }
            }

            this.initAllCard = function() {
                for (card of cards) {
                    if (card.isFront()) {
                        card.flip();
                    }
                }
            }

            this.connectCardToCardImageNumber = function() {
                cardAllImageNumber.splice(0);
                for (card of cards) {
                    cardAllImageNumber.push(card.getCardImageNumber());
                }
            }

            this.initDeck = function() {
                this.shuffle();
                this.initAllCard();
                this.connectCardToCardImageNumber();
                selectedCardForHint.splice(0);
                currentPlayerTwoSelectedCard.splice(0);
            }
            
            this.findCard = function(cardImageNumber){
                for (card of cards) {
                    if (card.isSameCardImageNumber(cardImageNumber)) {
                        return card;
                    }
                }
            }

            this.isCurrentPlayerSelectedTwoCard = function() {
                return currentPlayerTwoSelectedCard.length === 2 ? true : false;
            }

            this.pushCurrentPlayerSelectedCard = function(selectedCard) {
                if (this.isCurrentPlayerSelectedTwoCard()) return;

                currentPlayerTwoSelectedCard.push(selectedCard);
            }

            this.shiftCurrentPlayerSelectedCard = function() {
                if (currentPlayerTwoSelectedCard.length  === 0) return;
                return currentPlayerTwoSelectedCard.shift();
            }

            this.isHintCard = function() {
                return selectedCardForHint.length > 0 ? true : false;
            }
        }
        // 1. 카드 객체 : 카드의 상태(앞면, 뒷면)과 카드 숫자 이미지를 저장, 그리고 그와 관련된 작업 묶음 
        function Card(cardImageNumber = 0, state = false) {
            var cardImageNumber = cardImageNumber; // 카드의 이미지 숫자 
            var state = state; // 카드의 상태값(앞면, 뒷면)

            // 카드가 앞면인지 응답
            this.isFront = function() {
                return state;
            }

            // 카드의 숫자 추출 
            this.getNumber = function() {
                return cardImageNumber % 13; 
            }

            // 카드의 모양 추출 
            this.getShape = function() {
                return Math.floor(cardImageNumber/13); 
            }

            // 카드의 색깔 추출  
            this.getColor = function() {
                return Math.floor(cardImageNumber/13)%2 === 0 ? "red" : "black";
            }

            // 카드의 이미지 숫자 반환 
            this.getCardImageNumber = function() {
                return cardImageNumber;
            }

            // 매개변수로 전달 받은 값과 얼마나 맞았는지 계산해서 반환 
            this.calculateSameCount = function(otherNumber, otherColor, otherShape) {
                return this.isSameNumber(otherNumber) + this.isSameColor(otherColor) + this.isSameShape(otherShape);
            }

            // 매개변수로 전달 받은 다른 카드의 숫자와 일치하는지 판단 
            this.isSameNumber = function(otherNumber) {
                return this.getNumber() === otherNumber ? 1 : 0;
            }

            // 매개변수로 전달 받은 다른 카드의 색깔과 일치하는지 판단 
            this.isSameColor = function(otherColor) {
                return this.getColor() === otherColor ? 1 : 0;
            }

            // 매개변수로 전달 받은 다른 카드의 모양과 일치하는지 판단 
            this.isSameShape = function(otherShape) {
                return this.getShape() === otherShape ? 1 : 0;
            }

            // 매개변수로 전달 받은 카드 이미지 숫자값과 맞는지 판단 
            this.isSameCardImageNumber = function(otherCardImageNumber) {
                return cardImageNumber === otherCardImageNumber ? true : false;
            }

            // 카드 뒤집기 
            this.flip = function() {
                state = !state;
            }
        }

        // 2. 플레이어 객체 : 이름, 점수, 남은 게임 횟수 저장하고 그와 관련된 작업을 묶음 
        function Player(name = "anonymous") {
            var name = name; // 이름 
            var score = 0; // 점수 
            var leftCount = 100; // 게임 횟수
            var leftHintCount = 3; // 힌트 횟수  

            // 자신이 승자인지, 패자인지, 무승부인지 판단(-1 : 자기가 이김, 0 : 무승부, 1 : 상대가 이김)
            this.isWinner = function(otherPlayerScore) {
                return score > otherPlayerScore ?  -1 : (score === otherPlayerScore ? 0: 1);
            }

            // 남은 횟수가 있는지 응답  
            this.isLeftCount =  function() {
                return leftCount > 0 ? true : false;
            }

            // 남은 힌트 횟수가 있는지 응답
            this.isLeftHintCount = function() {
                return leftHintCount > 0 ? true : false;
            }

            // 이름 반환 
            this.getName = function() {
                return name;
            }

            // 점수 반환 
            this.getScore = function() {
                return score;
            }

            // 남은 횟수 반환 
            this.getLeftCount = function() {
                return leftCount;
            }

            // 남은 힌트 횟수 반환
            this.getLeftHintCount = function() {
                return leftHintCount;
            }

            // 자신의 점수에 일정량만큼 더함 
            this.addScore = function(amount) {
                score += amount;
            }

            // 남은 횟수를 1 감소 
            this.decreaseCount = function() {
                if (leftCount > 0) {
                    leftCount--;
                }
            }

            // 남은 힌트 횟수를 1 감소
            this.decreaseHintCount = function() {
                if (leftHintCount > 0) {
                    leftHintCount--;
                }
            }

        }

        // 게임 결과 저장 객체 :
        function GameResult() {
            var map = new Map();

            this.createAllMessage = function() {
                if (firstPlayer instanceof Player && secondPlayer instanceof Player) {
                    map.set(-1, `"${firstPlayer.getName()}"이 이겼습니다.🔊`); 
                    map.set(0, `"${firstPlayer.getName()}"와 "${secondPlayer.getName()}"의 점수가 같습니다. 무승부입니다.🔊`);
                    map.set(1, `${secondPlayer.getName()}가 이겼습니다.🔊`);
                    return;
                }
            }

            
            this.translateGameMessage = function(gameResult) {
                return map.get(gameResult);
            }
        }

        // 3. 게임 매니저 객체 : 카드객체와 플레이어 객체를 포함해서, 전체 프로그램의 흐름을 담당
        function GameModerator() {

            var currentPlayerTwoSelectedCard = []; // 현재 플레이어가 선택한 카드를 저장 
            var gameResultMessage = new Map(); // 게임 결과 맵에 저장 


            // 게임이 시작했을 때 초기화면과 각 객체 상태 구성
            this.startGame = function() {
                // 덱에 있는 카드 섞기
                deck.shuffle();
                // 게임 메시지 셍성
                gameResult.createAllMessage();
                // 모든 카드 태그 생성해서 추가
                this.updateAllCardTag();
                // 모든 플레이어 태그 붙이기
                this.updateAllPlayerTag();
            }

            // 게임판 업데이트 
            this.updateGame = function() {
                // 덱에 있는 카드 다시 섞기
                deck.shuffle();
                // 카드 태그 생성해서 붙이기
                this.updateAllCardTag();
                // 플레이어 태그 업데이트하기
                this.updateAllPlayerTag();
            }

            this.updateGameBoard = function() {
                const cardAreaChildren = document.getElementById("cardArea").children;

                for (child of cardAreaChildren) {
                    const card = deck.selectCardInOrder();
                    if (card.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                        if (card.isFront()) {
                            child.setAttribute("src", `img/card_img/${card.getCardImageNumber()}.png`);
                        }
                    }
                }
            }


            // 모든 게임 결과 메시지를 생성해서 맵에 게임 결과 숫자와 매핑하여 저장 
            this.createGameResultMessage = function() {
                if (firstPlayer instanceof Player && secondPlayer instanceof Player) {
                    gameResultMessage.set(-1, `"${firstPlayer.getName()}"이 이겼습니다.🔊`); 
                    gameResultMessage.set(0, `"${firstPlayer.getName()}"와 "${secondPlayer.getName()}"의 점수가 같습니다. 무승부입니다.🔊`);
                    gameResultMessage.set(1, `${secondPlayer.getName()}가 이겼습니다.🔊`);
                }
            }

            // 모든 카드 객체의 태그를 생성해서 추가 
            this.updateAllCardTag = function() {
                const cardArea = document.getElementById("cardArea");
                cardArea.innerHTML = "";

                for (let i=0; i<deck.getLengthOfAllCard(); i++) {
                    const card = deck.indexOfCard(i);
                    const imgTag = document.createElement("img");

                    if (card.isFront()) {
                        imgTag.setAttribute("src", `img/card_img/${card.getCardImageNumber()}.png`);
                    } else {
                        imgTag.setAttribute("src", `img/card_img/back.png`);
                    }

                    imgTag.setAttribute("data-number", card.getCardImageNumber());
                    imgTag.setAttribute("onclick", "selectCardTag(this)");
                    cardArea.appendChild(imgTag);
                }
            }

            // 모든 플레이어의 태그 업데이트 
            this.updateAllPlayerTag = function() {
                const firstPlayerArea = document.getElementById("firstPlayerArea");
                const secondPlayerArea = document.getElementById("secondPlayerArea");

                if (firstPlayer instanceof Player) {
                    firstPlayerArea.innerHTML = `<h3 class="title">${firstPlayer.getName()}</h3>`;
                    firstPlayerArea.innerHTML += `<br>`;
                    firstPlayerArea.innerHTML += `<p class="record"><strong>👉 남은 횟수-${firstPlayer.getLeftCount()}, 현재 점수-${firstPlayer.getScore()}, 남은 힌트-${firstPlayer.getLeftHintCount()} 👯‍♀️</strong></p>`;    
                }
                
                if (secondPlayer instanceof Player) {
                    secondPlayerArea.innerHTML = `<h3 class="title">${secondPlayer.getName()}</h3>`
                    secondPlayerArea.innerHTML += `<br>`;
                    secondPlayerArea.innerHTML += `<p class="record"><strong>👉 남은 횟수-${secondPlayer.getLeftCount()}, 현재 점수-${secondPlayer.getScore()}, 남은 힌트-${secondPlayer.getLeftHintCount()} 👯‍♀️</strong></p>`;
                }
            }

            
            // 첫번째 플레이어를 현재 플레이어로 설정 
            this.setFirstPlayerOnCurrentPlayer = function() {
                if (firstPlayer === null) {
                    alert('첫번째 플레이어를 생성하고 "플레이어1 시작"버튼을 눌러주세요.💥');
                    return;
                }

                currentPlayer = firstPlayer;
            }

            // 두번째 플레이어를 현재 플레이어로 설정 
            this.setSecondPlayerOnCurrentPlayer = function() {
                if (secondPlayer === null) {
                    alert('두번째 플레이어를 생성하고 "플레이어2 시작" 버튼을 눌러주새요.💥');
                    return;
                }

                currentPlayer = secondPlayer;
            }

            // 현재 플레이어가 카드를 선택했을 때 처리해줘야 할 작업 
            this.occurPlayerSelectCard = function(selectedCardTag) {
                // 현재 플레이어 객체가 설정되지 않은 경우 
                if (!(currentPlayer instanceof Player)) { 
                    // 현재 상태 알려주기 
                    alert("플레이어 시작 버튼을 누르고 게임을 진행하세요.🔊");
                    return;
                }

                // 현재 플레이어가 모든 횟수를 다 소진한 경우
                if (!currentPlayer.isLeftCount()) { 
                    // 현재 상태 알려주기 
                    alert(`"${currentPlayer.getName()}"의 게임 횟수가 ${currentPlayer.getLeftCount()}입니다.🔊`);
                    alert(`"${currentPlayer.getName()}"의 점수는 ${currentPlayer.getScore()}입니다.🔊`);
                    // 태그 업데이트 
                    this.updateAllPlayerTag();
                    return;
                }

                // 플레이어가 선택한 태그에 대응되는 카드 가져옴 
                const currentPlayerSelectedCard = this.findSelectedCardByTag(selectedCardTag);
                if (currentPlayerSelectedCard.isFront()) {
                    // 앞면인 경우 건너뛰기
                    return; 
                }

                // 첫번째 카드와 힌트 카드 비교
                let sameCountForFirstSelectedCardWithHint = 0;
                // 두번째 카드와 힌트 카드 비교 
                let sameCountForSecondSelectecCardWithHint = 0;
                // 힌트 카드와 이전에 선택한 카드 먼저 비교 
                for (let i=0; i<deck.getLengthOfCardForHint(); i++) {
                    // 힌트 카드 하나씩 참조
                    const cardForHint = deck.indexOfCardForHint(i);
                    // 현재 플레이어가 선택한 카드 하나씩 참조 
                    for (let j=0; j<deck.getLengthOfCurrentPlayerSelectedCard(); j++) {
                        const selectedCard = deck.indexOfCard(j);
                        // 서로 일치하는 갯수 카운트 
                        const amount = selectedCard.calculateSameCount(cardForHint.getNumber(), cardForHint.getColor(), cardForHint.getShape());
                        
                        // 첫 번째 카드인 경우 "첫 번째 카드와 힌트 카드 비교"에 기록
                        if (j === 0) {
                            sameCountForFirstSelectedCardWithHint += amount;
                        } 
                        // 두 번째 카드인 경우 "두 번째 카드와 힌트 카드 비교"에 기록
                        else {
                            sameCountForSecondSelectecCardWithHint += amount;
                        }

                        // 스코어 업데이트
                        currentPlayer.addScore(amount);
                        // 태그 업데이트 
                        this.updateAllPlayerTag();
                    }
                }

                // 두개의 카드를 선택했으면 서로 비교 
                if (deck.isCurrentPlayerSelectedTwoCard()) {
                    // 두개의 카드 서로 일치하는 갯수 카운트 및 뒤집기 
                    const amount = this.getSameAmountBetweenTwoSelectedCard(sameCountForFirstSelectedCardWithHint, sameCountForSecondSelectecCardWithHint);
                    // 스코어 업데이트 
                    currentPlayer.addScore(amount);
                    // 판수 업데이트 
                    currentPlayer.decreaseCount();
                    // 태그 업데이트 
                    this.updateAllPlayerTag();
                    return;
                }

                // 카드 객체에 현재 플레이어가 선택한 카드 저장 
                deck.pushCurrentPlayerSelectedCard(currentPlayerSelectedCard);
                // 선택한 카드 보여주기
                this.showSelectedCard(selectedCardTag);
            }

            // 현재 플레이어가 선택한 2개의 카드 중에서 무엇이 맞는지 숫자로 반환(숫자, 색깔, 도형)
            this.getSameAmountBetweenTwoSelectedCard = function(sameAmountWithHintForFirstCard, sameAmountWithHintForSecondCard) {
                const firstSelectedCard = deck.shiftCurrentPlayerSelectedCard();
                const secondSelectedCard = deck.shiftCurrentPlayerSelectedCard();
                const amount = firstSelectedCard.calculateSameCount(secondSelectedCard.getNumber(), secondSelectedCard.getColor(), secondSelectedCard.getShape());
                const cardAreaChildren = document.getElementById("cardArea").children; // 해당 카드 객체에 해당하는 태그의 속성 업데이트(뒷면으로 설정)    

                // 선택한 두 카드의 숫자, 컬러, 모양 안 맞은 경우
                if (amount === 0) { 
                    // 모든 힌트 카드와 선택한 두카드가 서로 일치하는게 하나도 없을 때, 모두 뒤집기
                    if (sameAmountWithHintForFirstCard === 0 && sameAmountWithHintForSecondCard === 0) {
                        firstSelectedCard.flip(); // 첫번째 카드 뒤집기 
                        secondSelectedCard.flip(); // 두번째 카드 뒤집기 
                        for (child of cardAreaChildren) {
                            if (firstSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number"))) || secondSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            } 
                        }
                    } 
                    // 모든 힌트 카드와 선택한 두 번째 카드가 서로 일치하는 게 없을 때, 두 번째 카드만 뒤집기
                    else if (sameAmountWithHintForFirstCard !== 0 && sameAmountWithHintForSecondCard === 0) {
                        secondSelectedCard.flip();
                        for (child of cardAreaChildren) {
                            if (secondSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            }
                        }
                    }
                    // 모든 힌트 카드와 선택한 첫 번째 카드가 서로 일치하는 게 없을 때, 첫 번째 카드만 뒤집기
                    else if (sameAmountWithHintForFirstCard === 0 && sameAmountWithHintForSecondCard !== 0) {
                        firstSelectedCard.flip();
                        for (child of cardAreaChildren) {
                            if (firstSelectedCard.isSameCardImageNumber(parseInt(child.getAttribute("data-number")))) {
                                child.setAttribute("src", `img/card_img/back.png`);
                            }
                        }
                    }
                } 
                
                // 두 카드가 일치하는 갯수 반환 
                return amount;
            }


            // 선택한 태그와 매칭되는 카드 객체 찾기 
            this.findSelectedCardByTag = function(selectedCardTag) {
                const selectedCardImageNumber = parseInt(selectedCardTag.getAttribute("data-number"));
                return deck.findCard(selectedCardImageNumber);
            }


            // 선택한 카드를 화면에 보여줌 
            this.showSelectedCard = function(selectedCardTag) {
                if (!currentPlayer.isLeftCount()) return; // 현재 플레이어의 게임 횟수가 0인 경우 
                const currentPlayerSelectedCard = this.findSelectedCardByTag(selectedCardTag); // 현재 플레이어가 선택한 태그에 해당하는 카드 객체 찾기 
                
                if (currentPlayerSelectedCard.isFront()) return; // 카드 객체가 앞면이면 스킵 
                currentPlayerSelectedCard.flip(); // 카드 객체가 뒷면이였으면, 돌리기 
                selectedCardTag.setAttribute("src", `img/card_img/${currentPlayerSelectedCard.getCardImageNumber()}.png`);  // 카드 태그의 속성 업데이트 
            }

            // 게임 결과를 숫자로 조회 
            this.getGameResult = function() {
                if (firstPlayer.isLeftCount() || secondPlayer.isLeftCount()) { // 플레이어의 게임 횟수가 남아있는 경우, 스킵 
                    alert(`아직 플레이어의 판수가 남아있습니다. 모든 플레이어의 판수 다 끝나면 요청해주세요.🔊`);
                    return false;
                }

                const result = firstPlayer.isWinner(secondPlayer.getScore()); // 게임 결과를 숫자로 반환
                this.notifyGameResult(result); // 숫자 결과를 문자 결과로 반환해서 출력 
                return true;
            }

            // 게임 결과 메시지로 발표 
            this.notifyGameResult = function(result) {
                const resultMessage = gameResultMessage.get(result);
                alert(resultMessage);
            }

            // 현재 플레이어의 이름을 반환 
            this.getCurrentPlayerName = function() {
                return currentPlayer.getName();
            }

            // 모든 플레이어를 초기화 
            this.resetAllPlayer = function() {
                alert("플레이어의 기록을 초기화합니다.💥");
                firstPlayer = null; 
                secondPlayer = null; 
            }
        }

    </script>
</body>
</html>
